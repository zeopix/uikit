(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["UIkit"] = factory();
	else
		root["UIkit"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/uikit.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://UIkit/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://UIkit/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://UIkit/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://UIkit/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/images/components/close-icon.svg":
/*!**********************************************!*\
  !*** ./src/images/components/close-icon.svg ***!
  \**********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"13\\\" y2=\\\"13\\\" />\\n    <line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"13\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/close-icon.svg?");

/***/ }),

/***/ "./src/images/components/close-large.svg":
/*!***********************************************!*\
  !*** ./src/images/components/close-large.svg ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"19\\\" y2=\\\"19\\\" />\\n    <line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"19\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"19\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/close-large.svg?");

/***/ }),

/***/ "./src/images/components/marker.svg":
/*!******************************************!*\
  !*** ./src/images/components/marker.svg ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t<rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"11\\\" />\\n\\t<rect x=\\\"4\\\" y=\\\"9\\\" width=\\\"11\\\" height=\\\"1\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/marker.svg?");

/***/ }),

/***/ "./src/images/components/navbar-toggle-icon.svg":
/*!******************************************************!*\
  !*** ./src/images/components/navbar-toggle-icon.svg ***!
  \******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <rect y=\\\"9\\\" width=\\\"20\\\" height=\\\"2\\\" />\\n    <rect y=\\\"3\\\" width=\\\"20\\\" height=\\\"2\\\" />\\n    <rect y=\\\"15\\\" width=\\\"20\\\" height=\\\"2\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/navbar-toggle-icon.svg?");

/***/ }),

/***/ "./src/images/components/overlay-icon.svg":
/*!************************************************!*\
  !*** ./src/images/components/overlay-icon.svg ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <rect x=\\\"19\\\" y=\\\"0\\\" width=\\\"1\\\" height=\\\"40\\\" />\\n    <rect x=\\\"0\\\" y=\\\"19\\\" width=\\\"40\\\" height=\\\"1\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/overlay-icon.svg?");

/***/ }),

/***/ "./src/images/components/pagination-next.svg":
/*!***************************************************!*\
  !*** ./src/images/components/pagination-next.svg ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 1 6 6 1 11\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/pagination-next.svg?");

/***/ }),

/***/ "./src/images/components/pagination-previous.svg":
/*!*******************************************************!*\
  !*** ./src/images/components/pagination-previous.svg ***!
  \*******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"6 1 1 6 6 11\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/pagination-previous.svg?");

/***/ }),

/***/ "./src/images/components/search-icon.svg":
/*!***********************************************!*\
  !*** ./src/images/components/search-icon.svg ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"7\\\" />\\n    <path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M14,14 L18,18 L14,14 Z\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/search-icon.svg?");

/***/ }),

/***/ "./src/images/components/search-large.svg":
/*!************************************************!*\
  !*** ./src/images/components/search-large.svg ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" cx=\\\"17.5\\\" cy=\\\"17.5\\\" r=\\\"16.5\\\" />\\n    <line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" x1=\\\"38\\\" y1=\\\"39\\\" x2=\\\"29\\\" y2=\\\"30\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/search-large.svg?");

/***/ }),

/***/ "./src/images/components/search-navbar.svg":
/*!*************************************************!*\
  !*** ./src/images/components/search-navbar.svg ***!
  \*************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"9.5\\\" />\\n    <line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"23\\\" y1=\\\"23\\\" x2=\\\"17\\\" y2=\\\"17\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/search-navbar.svg?");

/***/ }),

/***/ "./src/images/components/slidenav-next-large.svg":
/*!*******************************************************!*\
  !*** ./src/images/components/slidenav-next-large.svg ***!
  \*******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"25px\\\" height=\\\"40px\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\r\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"4.002,38.547 22.527,20.024 4,1.5 \\\" />\\r\\n</svg>\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/slidenav-next-large.svg?");

/***/ }),

/***/ "./src/images/components/slidenav-next.svg":
/*!*************************************************!*\
  !*** ./src/images/components/slidenav-next.svg ***!
  \*************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"14px\\\" height=\\\"24px\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\r\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"1.225,23 12.775,12 1.225,1 \\\" />\\r\\n</svg>\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/slidenav-next.svg?");

/***/ }),

/***/ "./src/images/components/slidenav-previous-large.svg":
/*!***********************************************************!*\
  !*** ./src/images/components/slidenav-previous-large.svg ***!
  \***********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"25px\\\" height=\\\"40px\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\r\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"20.527,1.5 2,20.024 20.525,38.547 \\\" />\\r\\n</svg>\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/slidenav-previous-large.svg?");

/***/ }),

/***/ "./src/images/components/slidenav-previous.svg":
/*!*****************************************************!*\
  !*** ./src/images/components/slidenav-previous.svg ***!
  \*****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"14px\\\" height=\\\"24px\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\r\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"12.775,1 1.225,12 12.775,23 \\\" />\\r\\n</svg>\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/slidenav-previous.svg?");

/***/ }),

/***/ "./src/images/components/spinner.svg":
/*!*******************************************!*\
  !*** ./src/images/components/spinner.svg ***!
  \*******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"15\\\" cy=\\\"15\\\" r=\\\"14\\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/spinner.svg?");

/***/ }),

/***/ "./src/images/components/totop.svg":
/*!*****************************************!*\
  !*** ./src/images/components/totop.svg ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("module.exports = \"<svg width=\\\"18\\\" height=\\\"10\\\" viewBox=\\\"0 0 18 10\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 9 9 1 17 9 \\\" />\\n</svg>\\n\"\n\n//# sourceURL=webpack://UIkit/./src/images/components/totop.svg?");

/***/ }),

/***/ "./src/js/uikit.js":
/*!**************************************!*\
  !*** ./src/js/uikit.js + 86 modules ***!
  \**************************************/
/*! exports provided: default */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/close-icon.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/close-large.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/marker.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/navbar-toggle-icon.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/overlay-icon.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/pagination-next.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/pagination-previous.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/search-icon.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/search-large.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/search-navbar.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/slidenav-next-large.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/slidenav-next.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/slidenav-previous-large.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/slidenav-previous.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/spinner.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/images/components/totop.svg (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/js/util/lang.js because of ./src/js/util/promise.js */
/*! ModuleConcatenation bailout: Cannot concat with ./src/js/util/promise.js (<- Module uses injected variables (setImmediate)) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var util_namespaceObject = {};\n__webpack_require__.d(util_namespaceObject, \"ajax\", function() { return ajax; });\n__webpack_require__.d(util_namespaceObject, \"getImage\", function() { return getImage; });\n__webpack_require__.d(util_namespaceObject, \"transition\", function() { return transition; });\n__webpack_require__.d(util_namespaceObject, \"Transition\", function() { return Transition; });\n__webpack_require__.d(util_namespaceObject, \"animate\", function() { return animation_animate; });\n__webpack_require__.d(util_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(util_namespaceObject, \"attr\", function() { return attr_attr; });\n__webpack_require__.d(util_namespaceObject, \"hasAttr\", function() { return hasAttr; });\n__webpack_require__.d(util_namespaceObject, \"removeAttr\", function() { return removeAttr; });\n__webpack_require__.d(util_namespaceObject, \"filterAttr\", function() { return filterAttr; });\n__webpack_require__.d(util_namespaceObject, \"data\", function() { return attr_data; });\n__webpack_require__.d(util_namespaceObject, \"addClass\", function() { return addClass; });\n__webpack_require__.d(util_namespaceObject, \"removeClass\", function() { return removeClass; });\n__webpack_require__.d(util_namespaceObject, \"removeClasses\", function() { return removeClasses; });\n__webpack_require__.d(util_namespaceObject, \"replaceClass\", function() { return replaceClass; });\n__webpack_require__.d(util_namespaceObject, \"hasClass\", function() { return hasClass; });\n__webpack_require__.d(util_namespaceObject, \"toggleClass\", function() { return toggleClass; });\n__webpack_require__.d(util_namespaceObject, \"$\", function() { return $; });\n__webpack_require__.d(util_namespaceObject, \"$$\", function() { return $$; });\n__webpack_require__.d(util_namespaceObject, \"positionAt\", function() { return positionAt; });\n__webpack_require__.d(util_namespaceObject, \"offset\", function() { return dimensions_offset; });\n__webpack_require__.d(util_namespaceObject, \"position\", function() { return dimensions_position; });\n__webpack_require__.d(util_namespaceObject, \"height\", function() { return dimensions_height; });\n__webpack_require__.d(util_namespaceObject, \"width\", function() { return dimensions_width; });\n__webpack_require__.d(util_namespaceObject, \"flipPosition\", function() { return flipPosition; });\n__webpack_require__.d(util_namespaceObject, \"isInView\", function() { return isInView; });\n__webpack_require__.d(util_namespaceObject, \"scrolledOver\", function() { return scrolledOver; });\n__webpack_require__.d(util_namespaceObject, \"isReady\", function() { return isReady; });\n__webpack_require__.d(util_namespaceObject, \"ready\", function() { return ready; });\n__webpack_require__.d(util_namespaceObject, \"index\", function() { return dom_index; });\n__webpack_require__.d(util_namespaceObject, \"getIndex\", function() { return getIndex; });\n__webpack_require__.d(util_namespaceObject, \"empty\", function() { return empty; });\n__webpack_require__.d(util_namespaceObject, \"html\", function() { return dom_html; });\n__webpack_require__.d(util_namespaceObject, \"prepend\", function() { return prepend; });\n__webpack_require__.d(util_namespaceObject, \"append\", function() { return append; });\n__webpack_require__.d(util_namespaceObject, \"before\", function() { return before; });\n__webpack_require__.d(util_namespaceObject, \"after\", function() { return after; });\n__webpack_require__.d(util_namespaceObject, \"remove\", function() { return remove; });\n__webpack_require__.d(util_namespaceObject, \"wrapAll\", function() { return wrapAll; });\n__webpack_require__.d(util_namespaceObject, \"wrapInner\", function() { return wrapInner; });\n__webpack_require__.d(util_namespaceObject, \"unwrap\", function() { return unwrap; });\n__webpack_require__.d(util_namespaceObject, \"fragment\", function() { return fragment; });\n__webpack_require__.d(util_namespaceObject, \"apply\", function() { return dom_apply; });\n__webpack_require__.d(util_namespaceObject, \"isRtl\", function() { return isRtl; });\n__webpack_require__.d(util_namespaceObject, \"hasTouch\", function() { return hasTouch; });\n__webpack_require__.d(util_namespaceObject, \"pointerDown\", function() { return pointerDown; });\n__webpack_require__.d(util_namespaceObject, \"pointerMove\", function() { return pointerMove; });\n__webpack_require__.d(util_namespaceObject, \"pointerUp\", function() { return pointerUp; });\n__webpack_require__.d(util_namespaceObject, \"pointerEnter\", function() { return pointerEnter; });\n__webpack_require__.d(util_namespaceObject, \"pointerLeave\", function() { return pointerLeave; });\n__webpack_require__.d(util_namespaceObject, \"on\", function() { return on; });\n__webpack_require__.d(util_namespaceObject, \"off\", function() { return off; });\n__webpack_require__.d(util_namespaceObject, \"once\", function() { return once; });\n__webpack_require__.d(util_namespaceObject, \"trigger\", function() { return trigger; });\n__webpack_require__.d(util_namespaceObject, \"createEvent\", function() { return createEvent; });\n__webpack_require__.d(util_namespaceObject, \"toEventTargets\", function() { return toEventTargets; });\n__webpack_require__.d(util_namespaceObject, \"preventClick\", function() { return preventClick; });\n__webpack_require__.d(util_namespaceObject, \"fastdom\", function() { return fastdom; });\n__webpack_require__.d(util_namespaceObject, \"isVoidElement\", function() { return isVoidElement; });\n__webpack_require__.d(util_namespaceObject, \"isVisible\", function() { return isVisible; });\n__webpack_require__.d(util_namespaceObject, \"selInput\", function() { return selInput; });\n__webpack_require__.d(util_namespaceObject, \"isInput\", function() { return isInput; });\n__webpack_require__.d(util_namespaceObject, \"filter\", function() { return filter_filter; });\n__webpack_require__.d(util_namespaceObject, \"within\", function() { return within; });\n__webpack_require__.d(util_namespaceObject, \"bind\", function() { return lang[\"bind\"]; });\n__webpack_require__.d(util_namespaceObject, \"hasOwn\", function() { return lang[\"hasOwn\"]; });\n__webpack_require__.d(util_namespaceObject, \"hyphenate\", function() { return lang[\"hyphenate\"]; });\n__webpack_require__.d(util_namespaceObject, \"camelize\", function() { return lang[\"camelize\"]; });\n__webpack_require__.d(util_namespaceObject, \"ucfirst\", function() { return lang[\"ucfirst\"]; });\n__webpack_require__.d(util_namespaceObject, \"startsWith\", function() { return lang[\"startsWith\"]; });\n__webpack_require__.d(util_namespaceObject, \"endsWith\", function() { return lang[\"endsWith\"]; });\n__webpack_require__.d(util_namespaceObject, \"includes\", function() { return lang[\"includes\"]; });\n__webpack_require__.d(util_namespaceObject, \"isArray\", function() { return lang[\"isArray\"]; });\n__webpack_require__.d(util_namespaceObject, \"isFunction\", function() { return lang[\"isFunction\"]; });\n__webpack_require__.d(util_namespaceObject, \"isObject\", function() { return lang[\"isObject\"]; });\n__webpack_require__.d(util_namespaceObject, \"isPlainObject\", function() { return lang[\"isPlainObject\"]; });\n__webpack_require__.d(util_namespaceObject, \"isWindow\", function() { return lang[\"isWindow\"]; });\n__webpack_require__.d(util_namespaceObject, \"isDocument\", function() { return lang[\"isDocument\"]; });\n__webpack_require__.d(util_namespaceObject, \"isJQuery\", function() { return lang[\"isJQuery\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNode\", function() { return lang[\"isNode\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNodeCollection\", function() { return lang[\"isNodeCollection\"]; });\n__webpack_require__.d(util_namespaceObject, \"isBoolean\", function() { return lang[\"isBoolean\"]; });\n__webpack_require__.d(util_namespaceObject, \"isString\", function() { return lang[\"isString\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNumber\", function() { return lang[\"isNumber\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNumeric\", function() { return lang[\"isNumeric\"]; });\n__webpack_require__.d(util_namespaceObject, \"isUndefined\", function() { return lang[\"isUndefined\"]; });\n__webpack_require__.d(util_namespaceObject, \"toBoolean\", function() { return lang[\"toBoolean\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNumber\", function() { return lang[\"toNumber\"]; });\n__webpack_require__.d(util_namespaceObject, \"toFloat\", function() { return lang[\"toFloat\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNode\", function() { return lang[\"toNode\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNodes\", function() { return lang[\"toNodes\"]; });\n__webpack_require__.d(util_namespaceObject, \"toList\", function() { return lang[\"toList\"]; });\n__webpack_require__.d(util_namespaceObject, \"toMs\", function() { return lang[\"toMs\"]; });\n__webpack_require__.d(util_namespaceObject, \"swap\", function() { return lang[\"swap\"]; });\n__webpack_require__.d(util_namespaceObject, \"assign\", function() { return lang[\"assign\"]; });\n__webpack_require__.d(util_namespaceObject, \"each\", function() { return lang[\"each\"]; });\n__webpack_require__.d(util_namespaceObject, \"sortBy\", function() { return lang[\"sortBy\"]; });\n__webpack_require__.d(util_namespaceObject, \"clamp\", function() { return lang[\"clamp\"]; });\n__webpack_require__.d(util_namespaceObject, \"noop\", function() { return lang[\"noop\"]; });\n__webpack_require__.d(util_namespaceObject, \"intersectRect\", function() { return lang[\"intersectRect\"]; });\n__webpack_require__.d(util_namespaceObject, \"pointInRect\", function() { return lang[\"pointInRect\"]; });\n__webpack_require__.d(util_namespaceObject, \"Dimensions\", function() { return lang[\"Dimensions\"]; });\n__webpack_require__.d(util_namespaceObject, \"MouseTracker\", function() { return MouseTracker; });\n__webpack_require__.d(util_namespaceObject, \"mergeOptions\", function() { return mergeOptions; });\n__webpack_require__.d(util_namespaceObject, \"parseOptions\", function() { return parseOptions; });\n__webpack_require__.d(util_namespaceObject, \"Player\", function() { return player_Player; });\n__webpack_require__.d(util_namespaceObject, \"Promise\", function() { return util_promise[\"Promise\"]; });\n__webpack_require__.d(util_namespaceObject, \"Deferred\", function() { return util_promise[\"Deferred\"]; });\n__webpack_require__.d(util_namespaceObject, \"query\", function() { return query; });\n__webpack_require__.d(util_namespaceObject, \"queryAll\", function() { return queryAll; });\n__webpack_require__.d(util_namespaceObject, \"find\", function() { return find; });\n__webpack_require__.d(util_namespaceObject, \"findAll\", function() { return findAll; });\n__webpack_require__.d(util_namespaceObject, \"matches\", function() { return selector_matches; });\n__webpack_require__.d(util_namespaceObject, \"closest\", function() { return closest; });\n__webpack_require__.d(util_namespaceObject, \"parents\", function() { return parents; });\n__webpack_require__.d(util_namespaceObject, \"escape\", function() { return selector_escape; });\n__webpack_require__.d(util_namespaceObject, \"css\", function() { return style_css; });\n__webpack_require__.d(util_namespaceObject, \"getStyles\", function() { return getStyles; });\n__webpack_require__.d(util_namespaceObject, \"getStyle\", function() { return getStyle; });\n__webpack_require__.d(util_namespaceObject, \"getCssVar\", function() { return getCssVar; });\n__webpack_require__.d(util_namespaceObject, \"propName\", function() { return style_propName; });\n__webpack_require__.d(util_namespaceObject, \"isTouch\", function() { return isTouch; });\n__webpack_require__.d(util_namespaceObject, \"getPos\", function() { return touch_getPos; });\n\n// EXTERNAL MODULE: ./src/js/util/lang.js\nvar lang = __webpack_require__(\"./src/js/util/lang.js\");\n\n// CONCATENATED MODULE: ./src/js/util/attr.js\n\n\nfunction attr_attr(element, name, value) {\n\n    if (Object(lang[\"isObject\"])(name)) {\n        for (const key in name) {\n            attr_attr(element, key, name[key]);\n        }\n        return;\n    }\n\n    if (Object(lang[\"isUndefined\"])(value)) {\n        element = Object(lang[\"toNode\"])(element);\n        return element && element.getAttribute(name);\n    } else {\n        Object(lang[\"toNodes\"])(element).forEach(element => {\n\n            if (Object(lang[\"isFunction\"])(value)) {\n                value = value.call(element, attr_attr(element, name));\n            }\n\n            if (value === null) {\n                removeAttr(element, name);\n            } else {\n                element.setAttribute(name, value);\n            }\n        });\n    }\n\n}\n\nfunction hasAttr(element, name) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.hasAttribute(name));\n}\n\nfunction removeAttr(element, name) {\n    element = Object(lang[\"toNodes\"])(element);\n    name.split(' ').forEach(name =>\n        element.forEach(element =>\n            element.removeAttribute(name)\n        )\n    );\n}\n\nfunction filterAttr(element, attribute, pattern, replacement) {\n    attr_attr(element, attribute, value => value ? value.replace(pattern, replacement) : value);\n}\n\nfunction attr_data(element, attribute) {\n    for (let i = 0, attrs = [attribute, `data-${attribute}`]; i < attrs.length; i++) {\n        if (hasAttr(element, attrs[i])) {\n            return attr_attr(element, attrs[i]);\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/util/selector.js\n\n\n\nfunction query(selector, context) {\n    return Object(lang[\"toNode\"])(selector) || find(selector, isContextSelector(selector) ? context : document);\n}\n\nfunction queryAll(selector, context) {\n    const nodes = Object(lang[\"toNodes\"])(selector);\n    return nodes.length && nodes || findAll(selector, isContextSelector(selector) ? context : document);\n}\n\nfunction find(selector, context) {\n    return Object(lang[\"toNode\"])(_query(selector, context, 'querySelector'));\n}\n\nfunction findAll(selector, context) {\n    return Object(lang[\"toNodes\"])(_query(selector, context, 'querySelectorAll'));\n}\n\nfunction _query(selector, context = document, queryFn) {\n\n    if (!selector || !Object(lang[\"isString\"])(selector)) {\n        return null;\n    }\n\n    selector = selector.replace(contextSanitizeRe, '$1 *');\n\n    let removes;\n\n    if (isContextSelector(selector)) {\n\n        removes = [];\n\n        selector = selector.split(',').map((selector, i) => {\n\n            let ctx = context;\n\n            selector = selector.trim();\n\n            if (selector[0] === '!') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                ctx = closest(context.parentNode, selectors[0]);\n                selector = selectors.slice(1).join(' ');\n\n            }\n\n            if (!ctx) {\n                return null;\n            }\n\n            if (!ctx.id) {\n                ctx.id = `uk-${Date.now()}${i}`;\n                removes.push(() => removeAttr(ctx, 'id'));\n            }\n\n            return `#${selector_escape(ctx.id)} ${selector}`;\n\n        }).filter(Boolean).join(',');\n\n        context = document;\n\n    }\n\n    try {\n\n        return context[queryFn](selector);\n\n    } catch (e) {\n\n        return null;\n\n    } finally {\n\n        removes && removes.forEach(remove => remove());\n\n    }\n\n}\n\nconst contextSelectorRe = /(^|,)\\s*[!>+~]/;\nconst contextSanitizeRe = /([!>+~])(?=\\s+[!>+~]|\\s*$)/g;\n\nfunction isContextSelector(selector) {\n    return Object(lang[\"isString\"])(selector) && selector.match(contextSelectorRe);\n}\n\nconst elProto = Element.prototype;\nconst matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;\n\nfunction selector_matches(element, selector) {\n    return Object(lang[\"toNodes\"])(element).some(element => matchesFn.call(element, selector));\n}\n\nconst closestFn = elProto.closest || function (selector) {\n    let ancestor = this;\n\n    do {\n\n        if (selector_matches(ancestor, selector)) {\n            return ancestor;\n        }\n\n        ancestor = ancestor.parentNode;\n\n    } while (ancestor && ancestor.nodeType === 1);\n};\n\nfunction closest(element, selector) {\n\n    if (Object(lang[\"startsWith\"])(selector, '>')) {\n        selector = selector.slice(1);\n    }\n\n    return Object(lang[\"isNode\"])(element)\n        ? element.parentNode && closestFn.call(element, selector)\n        : Object(lang[\"toNodes\"])(element).map(element => element.parentNode && closestFn.call(element, selector)).filter(Boolean);\n}\n\nfunction parents(element, selector) {\n    const elements = [];\n    let parent = Object(lang[\"toNode\"])(element).parentNode;\n\n    while (parent && parent.nodeType === 1) {\n\n        if (selector_matches(parent, selector)) {\n            elements.push(parent);\n        }\n\n        parent = parent.parentNode;\n    }\n\n    return elements;\n}\n\nconst escapeFn = window.CSS && CSS.escape || function (css) { return css.replace(/([^\\x7f-\\uFFFF\\w-])/g, match => `\\\\${match}`); };\nfunction selector_escape(css) {\n    return Object(lang[\"isString\"])(css) ? escapeFn.call(null, css) : '';\n}\n\n// CONCATENATED MODULE: ./src/js/util/filter.js\n\n\n\nconst voidElements = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nfunction isVoidElement(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => voidElements[element.tagName.toLowerCase()]);\n}\n\nfunction isVisible(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n\nconst selInput = 'input,select,textarea,button';\nfunction isInput(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => selector_matches(element, selInput));\n}\n\nfunction filter_filter(element, selector) {\n    return Object(lang[\"toNodes\"])(element).filter(element => selector_matches(element, selector));\n}\n\nfunction within(element, selector) {\n    return !Object(lang[\"isString\"])(selector)\n        ? element === selector || (Object(lang[\"isDocument\"])(selector)\n            ? selector.documentElement\n            : Object(lang[\"toNode\"])(selector)).contains(Object(lang[\"toNode\"])(element)) // IE 11 document does not implement contains\n        : selector_matches(element, selector) || closest(element, selector);\n}\n\n// CONCATENATED MODULE: ./src/js/util/event.js\n\n\n\n\nfunction on(...args) {\n\n    let [target, type, selector, listener, useCapture] = getArgs(args);\n\n    target = toEventTarget(target);\n\n    if (selector) {\n        listener = event_delegate(target, selector, listener);\n    }\n\n    if (listener.length > 1) {\n        listener = event_detail(listener);\n    }\n\n    type.split(' ').forEach(type => target && target.addEventListener(type, listener, useCapture));\n    return () => off(target, type, listener, useCapture);\n}\n\nfunction off(target, type, listener, useCapture = false) {\n    target = toEventTarget(target);\n    target && type.split(' ').forEach(type => target.removeEventListener(type, listener, useCapture));\n}\n\nfunction once(...args) {\n\n    const [element, type, selector, listener, useCapture, condition] = getArgs(args);\n    const off = on(element, type, selector, e => {\n        const result = !condition || condition(e);\n        if (result) {\n            off();\n            listener(e, result);\n        }\n    }, useCapture);\n\n    return off;\n}\n\nfunction trigger(target, event, detail) {\n    return toEventTargets(target).reduce((notCanceled, target) =>\n        notCanceled && target.dispatchEvent(createEvent(event, true, true, detail))\n        , true);\n}\n\nfunction createEvent(e, bubbles = true, cancelable = false, detail) {\n    if (Object(lang[\"isString\"])(e)) {\n        const event = document.createEvent('CustomEvent'); // IE 11\n        event.initCustomEvent(e, bubbles, cancelable, detail);\n        e = event;\n    }\n\n    return e;\n}\n\nfunction getArgs(args) {\n\n    if (Object(lang[\"isString\"])(args[0])) {\n        args[0] = find(args[0]);\n    }\n\n    if (Object(lang[\"isFunction\"])(args[2])) {\n        args.splice(2, 0, false);\n    }\n    return args;\n}\n\nfunction event_delegate(element, selector, listener) {\n    return e => {\n\n        const {target} = e;\n        const current = selector[0] === '>'\n            ? findAll(selector, element).reverse().filter(element => within(target, element))[0]\n            : closest(target, selector);\n\n        if (current) {\n            e.delegate = element;\n            e.current = current;\n\n            listener.call(this, e);\n        }\n    };\n}\n\nfunction event_detail(listener) {\n    return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n}\n\nfunction isEventTarget(target) {\n    return 'EventTarget' in window\n        ? target instanceof EventTarget\n        : target && 'addEventListener' in target;\n}\n\nfunction toEventTarget(target) {\n    return isEventTarget(target) ? target : Object(lang[\"toNode\"])(target);\n}\n\nfunction toEventTargets(target) {\n    return isEventTarget(target)\n        ? [target]\n        : Object(lang[\"isArray\"])(target)\n            ? target.map(toEventTarget).filter(Boolean)\n            : Object(lang[\"toNodes\"])(target);\n}\n\nfunction preventClick() {\n\n    const timer = setTimeout(once(document, 'click', e => {\n\n        e.preventDefault();\n        e.stopImmediatePropagation();\n\n        clearTimeout(timer);\n\n    }, true));\n\n    trigger(document, 'touchcancel');\n\n}\n\n// EXTERNAL MODULE: ./src/js/util/promise.js\nvar util_promise = __webpack_require__(\"./src/js/util/promise.js\");\n\n// CONCATENATED MODULE: ./src/js/util/ajax.js\n\n\n\n\nfunction ajax(url, options) {\n    return new util_promise[\"Promise\"]((resolve, reject) => {\n\n        const env = Object(lang[\"assign\"])({\n            data: null,\n            method: 'GET',\n            headers: {},\n            xhr: new XMLHttpRequest(),\n            beforeSend: lang[\"noop\"],\n            responseType: ''\n        }, options);\n\n        env.beforeSend(env);\n\n        const {xhr} = env;\n\n        for (const prop in env) {\n            if (prop in xhr) {\n                try {\n\n                    xhr[prop] = env[prop];\n\n                } catch (e) {}\n            }\n        }\n\n        xhr.open(env.method.toUpperCase(), url);\n\n        for (const header in env.headers) {\n            xhr.setRequestHeader(header, env.headers[header]);\n        }\n\n        on(xhr, 'load', () => {\n\n            if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n                resolve(xhr);\n            } else {\n                reject(Object(lang[\"assign\"])(Error(xhr.statusText), {\n                    xhr,\n                    status: xhr.status\n                }));\n            }\n\n        });\n\n        on(xhr, 'error', () => reject(Object(lang[\"assign\"])(Error('Network Error'), {xhr})));\n        on(xhr, 'timeout', () => reject(Object(lang[\"assign\"])(Error('Network Timeout'), {xhr})));\n\n        xhr.send(env.data);\n    });\n}\n\nfunction getImage(src) {\n\n    return new util_promise[\"Promise\"]((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = reject;\n        img.onload = () => resolve(img);\n\n        img.src = src;\n    });\n\n}\n\n// CONCATENATED MODULE: ./src/js/util/dom.js\n\n\n\nfunction isReady() {\n    return document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll;\n}\n\nfunction ready(fn) {\n\n    if (isReady()) {\n        fn();\n        return;\n    }\n\n    const handle = function () {\n        unbind1();\n        unbind2();\n        fn();\n    };\n    const unbind1 = on(document, 'DOMContentLoaded', handle);\n    const unbind2 = on(window, 'load', handle);\n}\n\nfunction dom_index(element, ref) {\n    return ref\n        ? Object(lang[\"toNodes\"])(element).indexOf(Object(lang[\"toNode\"])(ref))\n        : Object(lang[\"toNodes\"])((element = Object(lang[\"toNode\"])(element)) && element.parentNode.children).indexOf(element);\n}\n\nfunction getIndex(i, elements, current = 0, finite = false) {\n\n    elements = Object(lang[\"toNodes\"])(elements);\n\n    const {length} = elements;\n\n    i = Object(lang[\"isNumeric\"])(i)\n        ? Object(lang[\"toNumber\"])(i)\n        : i === 'next'\n            ? current + 1\n            : i === 'previous'\n                ? current - 1\n                : dom_index(elements, i);\n\n    if (finite) {\n        return Object(lang[\"clamp\"])(i, 0, length - 1);\n    }\n\n    i %= length;\n\n    return i < 0 ? i + length : i;\n}\n\nfunction empty(element) {\n    element = Object(lang[\"toNode\"])(element);\n    element.innerHTML = '';\n    return element;\n}\n\nfunction dom_html(parent, html) {\n    parent = Object(lang[\"toNode\"])(parent);\n    return Object(lang[\"isUndefined\"])(html)\n        ? parent.innerHTML\n        : append(parent.hasChildNodes() ? empty(parent) : parent, html);\n}\n\nfunction prepend(parent, element) {\n\n    parent = Object(lang[\"toNode\"])(parent);\n\n    if (!parent.hasChildNodes()) {\n        return append(parent, element);\n    } else {\n        return insertNodes(element, element => parent.insertBefore(element, parent.firstChild));\n    }\n}\n\nfunction append(parent, element) {\n    parent = Object(lang[\"toNode\"])(parent);\n    return insertNodes(element, element => parent.appendChild(element));\n}\n\nfunction before(ref, element) {\n    ref = Object(lang[\"toNode\"])(ref);\n    return insertNodes(element, element => ref.parentNode.insertBefore(element, ref));\n}\n\nfunction after(ref, element) {\n    ref = Object(lang[\"toNode\"])(ref);\n    return insertNodes(element, element => ref.nextSibling\n        ? before(ref.nextSibling, element)\n        : append(ref.parentNode, element)\n    );\n}\n\nfunction insertNodes(element, fn) {\n    element = Object(lang[\"isString\"])(element) ? fragment(element) : element;\n    return element\n        ? 'length' in element\n            ? Object(lang[\"toNodes\"])(element).map(fn)\n            : fn(element)\n        : null;\n}\n\nfunction remove(element) {\n    Object(lang[\"toNodes\"])(element).map(element => element.parentNode && element.parentNode.removeChild(element));\n}\n\nfunction wrapAll(element, structure) {\n\n    structure = Object(lang[\"toNode\"])(before(element, structure));\n\n    while (structure.firstChild) {\n        structure = structure.firstChild;\n    }\n\n    append(structure, element);\n\n    return structure;\n}\n\nfunction wrapInner(element, structure) {\n    return Object(lang[\"toNodes\"])(Object(lang[\"toNodes\"])(element).map(element =>\n        element.hasChildNodes ? wrapAll(Object(lang[\"toNodes\"])(element.childNodes), structure) : append(element, structure)\n    ));\n}\n\nfunction unwrap(element) {\n    Object(lang[\"toNodes\"])(element)\n        .map(element => element.parentNode)\n        .filter((value, index, self) => self.indexOf(value) === index)\n        .forEach(parent => {\n            before(parent, parent.childNodes);\n            remove(parent);\n        });\n}\n\nconst fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\nconst singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nfunction fragment(html) {\n\n    const matches = singleTagRe.exec(html);\n    if (matches) {\n        return document.createElement(matches[1]);\n    }\n\n    const container = document.createElement('div');\n    if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n    } else {\n        container.textContent = html;\n    }\n\n    return container.childNodes.length > 1 ? Object(lang[\"toNodes\"])(container.childNodes) : container.firstChild;\n\n}\n\nfunction dom_apply(node, fn) {\n\n    if (!node || node.nodeType !== 1) {\n        return;\n    }\n\n    fn(node);\n    node = node.firstElementChild;\n    while (node) {\n        dom_apply(node, fn);\n        node = node.nextElementSibling;\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/util/class.js\n\n\n\nfunction addClass(element, ...args) {\n    class_apply(element, args, 'add');\n}\n\nfunction removeClass(element, ...args) {\n    class_apply(element, args, 'remove');\n}\n\nfunction removeClasses(element, cls) {\n    filterAttr(element, 'class', new RegExp(`(^|\\\\s)${cls}(?!\\\\S)`, 'g'), '');\n}\n\nfunction replaceClass(element, ...args) {\n    args[0] && removeClass(element, args[0]);\n    args[1] && addClass(element, args[1]);\n}\n\nfunction hasClass(element, cls) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.classList.contains(cls));\n}\n\nfunction toggleClass(element, ...args) {\n\n    if (!args.length) {\n        return;\n    }\n\n    args = class_getArgs(args);\n\n    const force = !Object(lang[\"isString\"])(args[args.length - 1]) ? args.pop() : []; // in iOS 9.3 force === undefined evaluates to false\n\n    args = args.filter(Boolean);\n\n    Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        for (let i = 0; i < args.length; i++) {\n            supports.Force\n                ? classList.toggle(...[args[i]].concat(force))\n                : (classList[(!Object(lang[\"isUndefined\"])(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]));\n        }\n    });\n\n}\n\nfunction class_apply(element, args, fn) {\n    args = class_getArgs(args).filter(Boolean);\n\n    args.length && Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        supports.Multiple\n            ? classList[fn](...args)\n            : args.forEach(cls => classList[fn](cls));\n    });\n}\n\nfunction class_getArgs(args) {\n    return args.reduce((args, arg) =>\n        args.concat.call(args, Object(lang[\"isString\"])(arg) && Object(lang[\"includes\"])(arg, ' ') ? arg.trim().split(' ') : arg)\n        , []);\n}\n\nconst supports = {};\n\n// IE 11\n(function () {\n\n    let list = document.createElement('_').classList;\n    if (list) {\n        list.add('a', 'b');\n        list.toggle('c', false);\n        supports.Multiple = list.contains('b');\n        supports.Force = !list.contains('c');\n    }\n    list = null;\n\n})();\n\n// CONCATENATED MODULE: ./src/js/util/style.js\n\n\n\n\nconst cssNumber = {\n    'animation-iteration-count': true,\n    'column-count': true,\n    'fill-opacity': true,\n    'flex-grow': true,\n    'flex-shrink': true,\n    'font-weight': true,\n    'line-height': true,\n    'opacity': true,\n    'order': true,\n    'orphans': true,\n    'widows': true,\n    'z-index': true,\n    'zoom': true\n};\n\nfunction style_css(element, property, value) {\n\n    return Object(lang[\"toNodes\"])(element).map(element => {\n\n        if (Object(lang[\"isString\"])(property)) {\n\n            property = style_propName(property);\n\n            if (Object(lang[\"isUndefined\"])(value)) {\n                return getStyle(element, property);\n            } else if (!value && value !== 0) {\n                element.style.removeProperty(property);\n            } else {\n                element.style[property] = Object(lang[\"isNumeric\"])(value) && !cssNumber[property] ? `${value}px` : value;\n            }\n\n        } else if (Object(lang[\"isArray\"])(property)) {\n\n            const styles = getStyles(element);\n\n            return property.reduce((props, property) => {\n                props[property] = styles[style_propName(property)];\n                return props;\n            }, {});\n\n        } else if (Object(lang[\"isObject\"])(property)) {\n            Object(lang[\"each\"])(property, (value, property) => style_css(element, property, value));\n        }\n\n        return element;\n\n    })[0];\n\n}\n\nfunction getStyles(element, pseudoElt) {\n    element = Object(lang[\"toNode\"])(element);\n    return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);\n}\n\nfunction getStyle(element, property, pseudoElt) {\n    return getStyles(element, pseudoElt)[property];\n}\n\nconst vars = {};\n\nfunction getCssVar(name) {\n\n    if (!(name in vars)) {\n\n        /* usage in css: .var-name:before { content:\"xyz\" } */\n\n        const element = append(document.documentElement, document.createElement('div'));\n\n        addClass(element, `var-${name}`);\n\n        try {\n\n            vars[name] = getStyle(element, 'content', ':before').replace(/^[\"'](.*)[\"']$/, '$1');\n            vars[name] = JSON.parse(vars[name]);\n\n        } catch (e) {}\n\n        document.documentElement.removeChild(element);\n\n    }\n\n    return vars[name];\n\n}\n\nconst cssProps = {};\n\nfunction style_propName(name) {\n\n    let ret = cssProps[name];\n    if (!ret) {\n        ret = cssProps[name] = vendorPropName(name) || name;\n    }\n    return ret;\n}\n\nconst cssPrefixes = ['webkit', 'moz', 'ms'];\nconst {style: style_style} = document.createElement('_');\n\nfunction vendorPropName(name) {\n\n    name = Object(lang[\"hyphenate\"])(name);\n\n    if (name in style_style) {\n        return name;\n    }\n\n    let i = cssPrefixes.length, prefixedName;\n\n    while (i--) {\n        prefixedName = `-${cssPrefixes[i]}-${name}`;\n        if (prefixedName in style_style) {\n            return prefixedName;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/util/animation.js\n\n\n\n\n\n\n\nfunction transition(element, props, duration = 400, timing = 'linear') {\n\n    return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n        new util_promise[\"Promise\"]((resolve, reject) => {\n\n            for (const name in props) {\n                const value = style_css(element, name);\n                if (value === '') {\n                    style_css(element, name, value);\n                }\n            }\n\n            const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n            once(element, 'transitionend transitioncanceled', ({type}) => {\n                clearTimeout(timer);\n                removeClass(element, 'uk-transition');\n                style_css(element, {\n                    'transition-property': '',\n                    'transition-duration': '',\n                    'transition-timing-function': ''\n                });\n                type === 'transitioncanceled' ? reject() : resolve();\n            }, false, ({target}) => element === target);\n\n            addClass(element, 'uk-transition');\n            style_css(element, Object(lang[\"assign\"])({\n                'transition-property': Object.keys(props).map(style_propName).join(','),\n                'transition-duration': `${duration}ms`,\n                'transition-timing-function': timing\n            }, props));\n\n        })\n    ));\n\n}\n\nconst Transition = {\n\n    start: transition,\n\n    stop(element) {\n        trigger(element, 'transitionend');\n        return util_promise[\"Promise\"].resolve();\n    },\n\n    cancel(element) {\n        trigger(element, 'transitioncanceled');\n    },\n\n    inProgress(element) {\n        return hasClass(element, 'uk-transition');\n    }\n\n};\n\nconst animationPrefix = 'uk-animation-';\nconst clsCancelAnimation = 'uk-cancel-animation';\n\nfunction animation_animate(element, animation, duration = 200, origin, out) {\n\n    return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n        new util_promise[\"Promise\"]((resolve, reject) => {\n\n            if (hasClass(element, clsCancelAnimation)) {\n                requestAnimationFrame(() =>\n                    util_promise[\"Promise\"].resolve().then(() =>\n                        animation_animate(...arguments).then(resolve, reject)\n                    )\n                );\n                return;\n            }\n\n            let cls = `${animation} ${animationPrefix}${out ? 'leave' : 'enter'}`;\n\n            if (Object(lang[\"startsWith\"])(animation, animationPrefix)) {\n\n                if (origin) {\n                    cls += ` uk-transform-origin-${origin}`;\n                }\n\n                if (out) {\n                    cls += ` ${animationPrefix}reverse`;\n                }\n\n            }\n\n            reset();\n\n            once(element, 'animationend animationcancel', ({type}) => {\n\n                let hasReset = false;\n\n                if (type === 'animationcancel') {\n                    reject();\n                    reset();\n                } else {\n                    resolve();\n                    util_promise[\"Promise\"].resolve().then(() => {\n                        hasReset = true;\n                        reset();\n                    });\n                }\n\n                requestAnimationFrame(() => {\n                    if (!hasReset) {\n                        addClass(element, clsCancelAnimation);\n\n                        requestAnimationFrame(() => removeClass(element, clsCancelAnimation));\n                    }\n                });\n\n            }, false, ({target}) => element === target);\n\n            style_css(element, 'animationDuration', `${duration}ms`);\n            addClass(element, cls);\n\n            function reset() {\n                style_css(element, 'animationDuration', '');\n                removeClasses(element, `${animationPrefix}\\\\S*`);\n            }\n\n        })\n    ));\n\n}\n\nconst animation_inProgress = new RegExp(`${animationPrefix}(enter|leave)`);\nconst Animation = {\n\n    in(element, animation, duration, origin) {\n        return animation_animate(element, animation, duration, origin, false);\n    },\n\n    out(element, animation, duration, origin) {\n        return animation_animate(element, animation, duration, origin, true);\n    },\n\n    inProgress(element) {\n        return animation_inProgress.test(attr_attr(element, 'class'));\n    },\n\n    cancel(element) {\n        trigger(element, 'animationcancel');\n    }\n\n};\n\n// CONCATENATED MODULE: ./src/js/util/core.js\n\n\n\n\nfunction $(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNode\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNode\"])(fragment(selector))\n            : find(selector, context);\n}\n\nfunction $$(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNodes\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNodes\"])(fragment(selector))\n            : findAll(selector, context);\n}\n\nfunction isHtml(str) {\n    return str[0] === '<' || str.match(/^\\s*</);\n}\n\n// CONCATENATED MODULE: ./src/js/util/dimensions.js\n\n\n\n\n\nconst dirs = {\n    width: ['x', 'left', 'right'],\n    height: ['y', 'top', 'bottom']\n};\n\nfunction positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {\n\n    elAttach = getPos(elAttach);\n    targetAttach = getPos(targetAttach);\n\n    const flipped = {element: elAttach, target: targetAttach};\n\n    if (!element || !target) {\n        return flipped;\n    }\n\n    const dim = getDimensions(element);\n    const targetDim = getDimensions(target);\n    const position = targetDim;\n\n    moveTo(position, elAttach, dim, -1);\n    moveTo(position, targetAttach, targetDim, 1);\n\n    elOffset = getOffsets(elOffset, dim.width, dim.height);\n    targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);\n\n    elOffset['x'] += targetOffset['x'];\n    elOffset['y'] += targetOffset['y'];\n\n    position.left += elOffset['x'];\n    position.top += elOffset['y'];\n\n    boundary = getDimensions(boundary || dimensions_window(element));\n\n    if (flip) {\n        Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n\n            if (!(flip === true || Object(lang[\"includes\"])(flip, dir))) {\n                return;\n            }\n\n            const elemOffset = elAttach[dir] === align\n                ? -dim[prop]\n                : elAttach[dir] === alignFlip\n                    ? dim[prop]\n                    : 0;\n\n            const targetOffset = targetAttach[dir] === align\n                ? targetDim[prop]\n                : targetAttach[dir] === alignFlip\n                    ? -targetDim[prop]\n                    : 0;\n\n            if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {\n\n                const centerOffset = dim[prop] / 2;\n                const centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;\n\n                elAttach[dir] === 'center' && (\n                    apply(centerOffset, centerTargetOffset)\n                    || apply(-centerOffset, -centerTargetOffset)\n                ) || apply(elemOffset, targetOffset);\n\n            }\n\n            function apply(elemOffset, targetOffset) {\n\n                const newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;\n\n                if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {\n                    position[align] = newVal;\n\n                    ['element', 'target'].forEach((el) => {\n                        flipped[el][dir] = !elemOffset\n                            ? flipped[el][dir]\n                            : flipped[el][dir] === dirs[prop][1]\n                                ? dirs[prop][2]\n                                : dirs[prop][1];\n                    });\n\n                    return true;\n                }\n\n            }\n\n        });\n    }\n\n    dimensions_offset(element, position);\n\n    return flipped;\n}\n\nfunction dimensions_offset(element, coordinates) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    if (coordinates) {\n\n        const currentOffset = dimensions_offset(element);\n        const pos = style_css(element, 'position');\n\n        ['left', 'top'].forEach(prop => {\n            if (prop in coordinates) {\n                const value = style_css(element, prop);\n                style_css(element, prop, coordinates[prop] - currentOffset[prop]\n                    + Object(lang[\"toFloat\"])(pos === 'absolute' && value === 'auto'\n                        ? dimensions_position(element)[prop]\n                        : value)\n                );\n            }\n        });\n\n        return;\n    }\n\n    return getDimensions(element);\n}\n\nfunction getDimensions(element) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const {scrollY: top, scrollX: left} = dimensions_window(element);\n\n    if (Object(lang[\"isWindow\"])(element)) {\n\n        const height = element.innerHeight;\n        const width = element.innerWidth;\n\n        return {\n            top,\n            left,\n            height,\n            width,\n            bottom: top + height,\n            right: left + width,\n        };\n    }\n\n    let style, hidden;\n\n    if (!isVisible(element)) {\n        style = attr_attr(element, 'style');\n        hidden = attr_attr(element, 'hidden');\n\n        attr_attr(element, {\n            style: `${style || ''};display:block !important;`,\n            hidden: null\n        });\n    }\n\n    const rect = element.getBoundingClientRect();\n\n    if (!Object(lang[\"isUndefined\"])(style)) {\n        attr_attr(element, {style, hidden});\n    }\n\n    return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top + top,\n        left: rect.left + left,\n        bottom: rect.bottom + top,\n        right: rect.right + left,\n    };\n}\n\nfunction dimensions_position(element) {\n    element = Object(lang[\"toNode\"])(element);\n\n    const parent = offsetParent(element);\n    const parentOffset = parent === docEl(element) ? {top: 0, left: 0} : dimensions_offset(parent);\n    const {top, left} = ['top', 'left'].reduce((props, prop) => {\n        const propName = Object(lang[\"ucfirst\"])(prop);\n        props[prop] -= parentOffset[prop]\n            + (Object(lang[\"toFloat\"])(style_css(element, `margin${propName}`)) || 0)\n            + (Object(lang[\"toFloat\"])(style_css(parent, `border${propName}Width`)) || 0);\n        return props;\n    }, dimensions_offset(element));\n\n    return {top, left};\n}\n\nfunction offsetParent(element) {\n\n    let parent = Object(lang[\"toNode\"])(element).offsetParent;\n\n    while (parent && style_css(parent, 'position') === 'static') {\n        parent = parent.offsetParent;\n    }\n\n    return parent || docEl(element);\n}\n\nconst dimensions_height = dimension('height');\nconst dimensions_width = dimension('width');\n\nfunction dimension(prop) {\n    const propName = Object(lang[\"ucfirst\"])(prop);\n    return (element, value) => {\n\n        element = Object(lang[\"toNode\"])(element);\n\n        if (Object(lang[\"isUndefined\"])(value)) {\n\n            if (Object(lang[\"isWindow\"])(element)) {\n                return element[`inner${propName}`];\n            }\n\n            if (Object(lang[\"isDocument\"])(element)) {\n                const doc = element.documentElement;\n                return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);\n            }\n\n            value = style_css(element, prop);\n            value = value === 'auto' ? element[`offset${propName}`] : Object(lang[\"toFloat\"])(value) || 0;\n\n            return value - boxModelAdjust(prop, element);\n\n        } else {\n\n            style_css(element, prop, !value && value !== 0\n                ? ''\n                : +value + boxModelAdjust(prop, element) + 'px'\n            );\n\n        }\n\n    };\n}\n\nfunction boxModelAdjust(prop, element) {\n    return style_css(element, 'boxSizing') === 'border-box'\n        ? dirs[prop].slice(1).map(lang[\"ucfirst\"]).reduce((value, prop) =>\n            value\n            + Object(lang[\"toFloat\"])(style_css(element, `padding${prop}`))\n            + Object(lang[\"toFloat\"])(style_css(element, `border${prop}Width`))\n            , 0)\n        : 0;\n}\n\nfunction moveTo(position, attach, dim, factor) {\n    Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n        if (attach[dir] === alignFlip) {\n            position[align] += dim[prop] * factor;\n        } else if (attach[dir] === 'center') {\n            position[align] += dim[prop] * factor / 2;\n        }\n    });\n}\n\nfunction getPos(pos) {\n\n    const x = /left|center|right/;\n    const y = /top|center|bottom/;\n\n    pos = (pos || '').split(' ');\n\n    if (pos.length === 1) {\n        pos = x.test(pos[0])\n            ? pos.concat(['center'])\n            : y.test(pos[0])\n                ? ['center'].concat(pos)\n                : ['center', 'center'];\n    }\n\n    return {\n        x: x.test(pos[0]) ? pos[0] : 'center',\n        y: y.test(pos[1]) ? pos[1] : 'center'\n    };\n}\n\nfunction getOffsets(offsets, width, height) {\n\n    const [x, y] = (offsets || '').split(' ');\n\n    return {\n        x: x ? Object(lang[\"toFloat\"])(x) * (Object(lang[\"endsWith\"])(x, '%') ? width / 100 : 1) : 0,\n        y: y ? Object(lang[\"toFloat\"])(y) * (Object(lang[\"endsWith\"])(y, '%') ? height / 100 : 1) : 0\n    };\n}\n\nfunction flipPosition(pos) {\n    switch (pos) {\n        case 'left':\n            return 'right';\n        case 'right':\n            return 'left';\n        case 'top':\n            return 'bottom';\n        case 'bottom':\n            return 'top';\n        default:\n            return pos;\n    }\n}\n\nfunction isInView(element, topOffset = 0, leftOffset = 0) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const [elTop, elLeft] = offsetPosition(element);\n    const win = dimensions_window(element);\n    const {scrollY: top, scrollX: left} = win;\n\n    return isVisible(element) && Object(lang[\"intersectRect\"])(\n        {\n            top: elTop,\n            left: elLeft,\n            bottom: elTop + element.offsetHeight,\n            right: elTop + element.offsetWidth\n        },\n        {\n            top,\n            left,\n            bottom: top + topOffset + dimensions_height(win),\n            right: left + leftOffset + dimensions_width(win)\n        }\n    );\n}\n\nfunction scrolledOver(element, heightOffset = 0) {\n\n    if (!isVisible(element)) {\n        return 0;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = dimensions_window(element);\n    const doc = dimensions_document(element);\n    const elHeight = element.offsetHeight + heightOffset;\n    const [top] = offsetPosition(element);\n    const vp = dimensions_height(win);\n    const vh = vp + Math.min(0, top - vp);\n    const diff = Math.max(0, vp - (dimensions_height(doc) + heightOffset - (top + elHeight)));\n\n    return Object(lang[\"clamp\"])(((vh + win.scrollY - top) / ((vh + (elHeight - (diff < vp ? diff : 0))) / 100)) / 100);\n}\n\nfunction offsetPosition(element) {\n    const offset = [0, 0];\n\n    do {\n\n        offset[0] += element.offsetTop;\n        offset[1] += element.offsetLeft;\n\n        if (style_css(element, 'position') === 'fixed') {\n            const win = dimensions_window(element);\n            offset[0] += win.scrollY;\n            offset[1] += win.scrollX;\n            return offset;\n        }\n\n    } while ((element = element.offsetParent));\n\n    return offset;\n}\n\nfunction dimensions_window(element) {\n    return Object(lang[\"isWindow\"])(element) ? element : dimensions_document(element).defaultView;\n}\n\nfunction dimensions_document(element) {\n    return Object(lang[\"toNode\"])(element).ownerDocument;\n}\n\nfunction docEl(element) {\n    return dimensions_document(element).documentElement;\n}\n\n// CONCATENATED MODULE: ./src/js/util/env.js\n/* global DocumentTouch */\n\n\nconst isRtl = attr_attr(document.documentElement, 'dir') === 'rtl';\n\nconst hasTouchEvents = 'ontouchstart' in window;\nconst hasPointerEvents = window.PointerEvent;\nconst hasTouch = hasTouchEvents\n    || window.DocumentTouch && document instanceof DocumentTouch\n    || navigator.maxTouchPoints; // IE >=11\n\nconst pointerDown = !hasTouch ? 'mousedown' : `mousedown ${hasTouchEvents ? 'touchstart' : 'pointerdown'}`;\nconst pointerMove = !hasTouch ? 'mousemove' : `mousemove ${hasTouchEvents ? 'touchmove' : 'pointermove'}`;\nconst pointerUp = !hasTouch ? 'mouseup' : `mouseup ${hasTouchEvents ? 'touchend' : 'pointerup'}`;\nconst pointerEnter = hasTouch && hasPointerEvents ? 'pointerenter' : 'mouseenter';\nconst pointerLeave = hasTouch && hasPointerEvents ? 'pointerleave' : 'mouseleave';\n\n// CONCATENATED MODULE: ./src/js/util/fastdom.js\n/*\n    Based on:\n    Copyright (c) 2016 Wilson Page wilsonpage@me.com\n    https://github.com/wilsonpage/fastdom\n*/\n\nconst fastdom = {\n\n    reads: [],\n    writes: [],\n\n    read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    clear(task) {\n        return fastdom_remove(this.reads, task) || fastdom_remove(this.writes, task);\n    },\n\n    flush() {\n\n        runTasks(this.reads);\n        runTasks(this.writes.splice(0, this.writes.length));\n\n        this.scheduled = false;\n\n        if (this.reads.length || this.writes.length) {\n            scheduleFlush();\n        }\n\n    }\n\n};\n\nfunction scheduleFlush() {\n    if (!fastdom.scheduled) {\n        fastdom.scheduled = true;\n        requestAnimationFrame(fastdom.flush.bind(fastdom));\n    }\n}\n\nfunction runTasks(tasks) {\n    let task;\n    while ((task = tasks.shift())) {\n        task();\n    }\n}\n\nfunction fastdom_remove(array, item) {\n    const index = array.indexOf(item);\n    return !!~index && !!array.splice(index, 1);\n}\n\n// CONCATENATED MODULE: ./src/js/util/mouse.js\n\n\n\nfunction MouseTracker() {}\n\nMouseTracker.prototype = {\n\n    positions: [],\n    position: null,\n\n    init() {\n\n        this.positions = [];\n        this.position = null;\n\n        let ticking = false;\n        this.unbind = on(document, 'mousemove', e => {\n\n            if (ticking) {\n                return;\n            }\n\n            setTimeout(() => {\n\n                const time = Date.now();\n                const {length} = this.positions;\n\n                if (length && (time - this.positions[length - 1].time > 100)) {\n                    this.positions.splice(0, length);\n                }\n\n                this.positions.push({time, x: e.pageX, y: e.pageY});\n\n                if (this.positions.length > 5) {\n                    this.positions.shift();\n                }\n\n                ticking = false;\n            }, 5);\n\n            ticking = true;\n        });\n\n    },\n\n    cancel() {\n        if (this.unbind) {\n            this.unbind();\n        }\n    },\n\n    movesTo(target) {\n\n        if (this.positions.length < 2) {\n            return false;\n        }\n\n        const p = dimensions_offset(target);\n        const position = this.positions[this.positions.length - 1];\n        const [prevPos] = this.positions;\n\n        if (p.left <= position.x && position.x <= p.right && p.top <= position.y && position.y <= p.bottom) {\n            return false;\n        }\n\n        const points = [\n            [{x: p.left, y: p.top}, {x: p.right, y: p.bottom}],\n            [{x: p.right, y: p.top}, {x: p.left, y: p.bottom}]\n        ];\n\n        if (p.right <= position.x) {\n            // empty\n        } else if (p.left >= position.x) {\n            points[0].reverse();\n            points[1].reverse();\n        } else if (p.bottom <= position.y) {\n            points[0].reverse();\n        } else if (p.top >= position.y) {\n            points[1].reverse();\n        }\n\n        return !!points.reduce((result, point) => {\n            return result + (slope(prevPos, point[0]) < slope(position, point[0]) && slope(prevPos, point[1]) > slope(position, point[1]));\n        }, 0);\n    }\n\n};\n\nfunction slope(a, b) {\n    return (b.y - a.y) / (b.x - a.x);\n}\n\n// CONCATENATED MODULE: ./src/js/util/options.js\n\n\nconst strats = {};\n\n// concat strategy\nstrats.args =\nstrats.events =\nstrats.init =\nstrats.created =\nstrats.beforeConnect =\nstrats.connected =\nstrats.ready =\nstrats.beforeDisconnect =\nstrats.disconnected =\nstrats.destroy = function (parentVal, childVal) {\n\n    parentVal = parentVal && !Object(lang[\"isArray\"])(parentVal) ? [parentVal] : parentVal;\n\n    return childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : Object(lang[\"isArray\"])(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n};\n\n// update strategy\nstrats.update = function (parentVal, childVal) {\n    return strats.args(parentVal, Object(lang[\"isFunction\"])(childVal) ? {read: childVal} : childVal);\n};\n\n// property strategy\nstrats.props = function (parentVal, childVal) {\n\n    if (Object(lang[\"isArray\"])(childVal)) {\n        childVal = childVal.reduce((value, key) => {\n            value[key] = String;\n            return value;\n        }, {});\n    }\n\n    return strats.methods(parentVal, childVal);\n};\n\n// extend strategy\nstrats.computed =\nstrats.methods = function (parentVal, childVal) {\n    return childVal\n        ? parentVal\n            ? Object(lang[\"assign\"])({}, parentVal, childVal)\n            : childVal\n        : parentVal;\n};\n\n// data strategy\nstrats.data = function (parentVal, childVal, vm) {\n\n    if (!vm) {\n\n        if (!childVal) {\n            return parentVal;\n        }\n\n        if (!parentVal) {\n            return childVal;\n        }\n\n        return function (vm) {\n            return mergeFnData(parentVal, childVal, vm);\n        };\n\n    }\n\n    return mergeFnData(parentVal, childVal, vm);\n};\n\nfunction mergeFnData(parentVal, childVal, vm) {\n    return strats.computed(\n        Object(lang[\"isFunction\"])(parentVal)\n            ? parentVal.call(vm, vm)\n            : parentVal,\n        Object(lang[\"isFunction\"])(childVal)\n            ? childVal.call(vm, vm)\n            : childVal\n    );\n}\n\n// default strategy\nconst defaultStrat = function (parentVal, childVal) {\n    return Object(lang[\"isUndefined\"])(childVal) ? parentVal : childVal;\n};\n\nfunction mergeOptions(parent, child, vm) {\n\n    const options = {};\n\n    if (Object(lang[\"isFunction\"])(child)) {\n        child = child.options;\n    }\n\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n        for (let i = 0, l = child.mixins.length; i < l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n    }\n\n    for (const key in parent) {\n        mergeKey(key);\n    }\n\n    for (const key in child) {\n        if (!Object(lang[\"hasOwn\"])(parent, key)) {\n            mergeKey(key);\n        }\n    }\n\n    function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n    }\n\n    return options;\n}\n\nfunction parseOptions(options, args = []) {\n\n    try {\n\n        return !options\n            ? {}\n            : Object(lang[\"startsWith\"])(options, '{')\n                ? JSON.parse(options)\n                : args.length && !Object(lang[\"includes\"])(options, ':')\n                    ? ({[args[0]]: options})\n                    : options.split(';').reduce((options, option) => {\n                        const [key, value] = option.split(/:(.*)/);\n                        if (key && !Object(lang[\"isUndefined\"])(value)) {\n                            options[key.trim()] = value.trim();\n                        }\n                        return options;\n                    }, {});\n\n    } catch (e) {\n        return {};\n    }\n\n}\n\n// CONCATENATED MODULE: ./src/js/util/player.js\n\n\n\n\n\nlet player_id = 0;\n\nclass player_Player {\n\n    constructor(el) {\n        this.id = ++player_id;\n        this.el = Object(lang[\"toNode\"])(el);\n    }\n\n    isVideo() {\n        return this.isYoutube() || this.isVimeo() || this.isHTML5();\n    }\n\n    isHTML5() {\n        return this.el.tagName === 'VIDEO';\n    }\n\n    isIFrame() {\n        return this.el.tagName === 'IFRAME';\n    }\n\n    isYoutube() {\n        return this.isIFrame() && !!this.el.src.match(/\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/(watch\\?v=[^&\\s]+|embed)|youtu\\.be\\/.*/);\n    }\n\n    isVimeo() {\n        return this.isIFrame() && !!this.el.src.match(/vimeo\\.com\\/video\\/.*/);\n    }\n\n    enableApi() {\n\n        if (this.ready) {\n            return this.ready;\n        }\n\n        const youtube = this.isYoutube();\n        const vimeo = this.isVimeo();\n\n        let poller;\n\n        if (youtube || vimeo) {\n\n            return this.ready = new util_promise[\"Promise\"](resolve => {\n\n                once(this.el, 'load', () => {\n                    if (youtube) {\n                        const listener = () => post(this.el, {event: 'listening', id: this.id});\n                        poller = setInterval(listener, 100);\n                        listener();\n                    }\n                });\n\n                listen(data => youtube && data.id === this.id && data.event === 'onReady' || vimeo && Number(data.player_id) === this.id)\n                    .then(() => {\n                        resolve();\n                        poller && clearInterval(poller);\n                    });\n\n                attr_attr(this.el, 'src', `${this.el.src}${Object(lang[\"includes\"])(this.el.src, '?') ? '&' : '?'}${youtube ? 'enablejsapi=1' : `api=1&player_id=${this.id}`}`);\n\n            });\n\n        }\n\n        return util_promise[\"Promise\"].resolve();\n\n    }\n\n    play() {\n\n        if (!this.isVideo()) {\n            return;\n        }\n\n        if (this.isIFrame()) {\n            this.enableApi().then(() => post(this.el, {func: 'playVideo', method: 'play'}));\n        } else if (this.isHTML5()) {\n            try {\n                const promise = this.el.play();\n\n                if (promise) {\n                    promise.catch(lang[\"noop\"]);\n                }\n            } catch (e) {}\n        }\n    }\n\n    pause() {\n\n        if (!this.isVideo()) {\n            return;\n        }\n\n        if (this.isIFrame()) {\n            this.enableApi().then(() => post(this.el, {func: 'pauseVideo', method: 'pause'}));\n        } else if (this.isHTML5()) {\n            this.el.pause();\n        }\n    }\n\n    mute() {\n\n        if (!this.isVideo()) {\n            return;\n        }\n\n        if (this.isIFrame()) {\n            this.enableApi().then(() => post(this.el, {func: 'mute', method: 'setVolume', value: 0}));\n        } else if (this.isHTML5()) {\n            this.el.muted = true;\n            attr_attr(this.el, 'muted', '');\n        }\n\n    }\n\n}\n\nfunction post(el, cmd) {\n    try {\n        el.contentWindow.postMessage(JSON.stringify(Object(lang[\"assign\"])({event: 'command'}, cmd)), '*');\n    } catch (e) {}\n}\n\nfunction listen(cb) {\n\n    return new util_promise[\"Promise\"](resolve => {\n\n        once(window, 'message', (_, data) => resolve(data), false, ({data}) => {\n\n            if (!data || !Object(lang[\"isString\"])(data)) {\n                return;\n            }\n\n            try {\n                data = JSON.parse(data);\n            } catch (e) {\n                return;\n            }\n\n            return data && cb(data);\n\n        });\n\n    });\n\n}\n\n// CONCATENATED MODULE: ./src/js/util/touch.js\n/*\n    Based on:\n    Copyright (c) 2010-2016 Thomas Fuchs\n    http://zeptojs.com/\n*/\n\n\n\n\n\nlet touch = {}, clickTimeout, swipeTimeout, tapTimeout, clicked;\n\nfunction swipeDirection({x1, x2, y1, y2}) {\n    return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down');\n}\n\nfunction cancelAll() {\n    clickTimeout && clearTimeout(clickTimeout);\n    swipeTimeout && clearTimeout(swipeTimeout);\n    tapTimeout && clearTimeout(tapTimeout);\n    clickTimeout = swipeTimeout = tapTimeout = null;\n    touch = {};\n}\n\nready(() => {\n\n    on(document, 'click', () => clicked = true, true);\n\n    on(document, pointerDown, e => {\n\n        const {target} = e;\n        const {x, y} = touch_getPos(e);\n        const now = Date.now();\n        const type = getType(e.type);\n\n        if (touch.type && touch.type !== type) {\n            return;\n        }\n\n        touch.el = 'tagName' in target ? target : target.parentNode;\n\n        clickTimeout && clearTimeout(clickTimeout);\n\n        touch.x1 = x;\n        touch.y1 = y;\n\n        if (touch.last && now - touch.last <= 250) {\n            touch = {};\n        }\n\n        touch.type = type;\n        touch.last = now;\n\n        clicked = e.button > 0;\n\n    });\n\n    on(document, pointerMove, e => {\n\n        if (e.defaultPrevented) {\n            return;\n        }\n\n        const {x, y} = touch_getPos(e);\n\n        touch.x2 = x;\n        touch.y2 = y;\n\n    });\n\n    on(document, pointerUp, ({type, target}) => {\n\n        if (touch.type !== getType(type)) {\n            return;\n        }\n\n        // swipe\n        if (touch.x2 && Math.abs(touch.x1 - touch.x2) > 30 || touch.y2 && Math.abs(touch.y1 - touch.y2) > 30) {\n\n            swipeTimeout = setTimeout(() => {\n                if (touch.el) {\n                    trigger(touch.el, 'swipe');\n                    trigger(touch.el, `swipe${swipeDirection(touch)}`);\n                }\n                touch = {};\n            });\n\n        // normal tap\n        } else if ('last' in touch) {\n\n            tapTimeout = setTimeout(() => trigger(touch.el, 'tap'));\n\n            // trigger single click after 350ms of inactivity\n            if (touch.el && type !== 'mouseup' && within(target, touch.el)) {\n                clickTimeout = setTimeout(() => {\n                    clickTimeout = null;\n                    if (touch.el && !clicked) {\n                        trigger(touch.el, 'click');\n                    }\n                    touch = {};\n                }, 350);\n            }\n\n        } else {\n            touch = {};\n        }\n\n    });\n\n    on(document, 'touchcancel', cancelAll);\n    on(window, 'scroll', cancelAll);\n\n});\n\nlet touching = false;\non(document, 'touchstart', () => touching = true, true);\non(document, 'click', () => {touching = false;});\non(document, 'touchcancel', () => touching = false, true);\n\nfunction isTouch(e) {\n    return touching || e.pointerType === 'touch';\n}\n\nfunction touch_getPos(e) {\n    const {touches, changedTouches} = e;\n    const {pageX: x, pageY: y} = touches && touches[0] || changedTouches && changedTouches[0] || e;\n\n    return {x, y};\n}\n\nfunction getType(type) {\n    return type.slice(0, 5);\n}\n\n// CONCATENATED MODULE: ./src/js/util/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./src/js/api/component.js\n\n\n/* harmony default export */ var api_component = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    const components = {};\n\n    UIkit.component = function (name, options) {\n\n        if (!options) {\n\n            if (Object(lang[\"isPlainObject\"])(components[name])) {\n                components[name] = UIkit.extend(components[name]);\n            }\n\n            return components[name];\n\n        }\n\n        UIkit[name] = function (element, data) {\n\n            const component = UIkit.component(name);\n\n            if (Object(lang[\"isPlainObject\"])(element)) {\n                return new component({data: element});\n            }\n\n            if (component.options.functional) {\n                return new component({data: [...arguments]});\n            }\n\n            return element && element.nodeType ? init(element) : $$(element).map(init)[0];\n\n            function init(element) {\n\n                const instance = UIkit.getComponent(element, name);\n\n                if (instance) {\n                    if (!data) {\n                        return instance;\n                    } else {\n                        instance.$destroy();\n                    }\n                }\n\n                return new component({el: element, data});\n\n            }\n\n        };\n\n        const opt = Object(lang[\"isPlainObject\"])(options) ? Object(lang[\"assign\"])({}, options) : options.options;\n\n        opt.name = name;\n\n        if (opt.install) {\n            opt.install(UIkit, opt, name);\n        }\n\n        if (UIkit._initialized && !opt.functional) {\n            const id = Object(lang[\"hyphenate\"])(id);\n            fastdom.read(() => UIkit[name](`[uk-${id}],[data-uk-${id}]`));\n        }\n\n        return components[name] = Object(lang[\"isPlainObject\"])(options) ? opt : options;\n    };\n\n    UIkit.getComponents = element => element && element[DATA] || {};\n    UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];\n\n    UIkit.connect = node => {\n\n        if (node[DATA]) {\n            for (const name in node[DATA]) {\n                node[DATA][name]._callConnected();\n            }\n        }\n\n        for (let i = 0; i < node.attributes.length; i++) {\n\n            const name = getComponentName(node.attributes[i].name);\n\n            if (name && name in components) {\n                UIkit[name](node);\n            }\n\n        }\n\n    };\n\n    UIkit.disconnect = node => {\n        for (const name in node[DATA]) {\n            node[DATA][name]._callDisconnected();\n        }\n    };\n\n});\n\nfunction getComponentName(attribute) {\n    return Object(lang[\"startsWith\"])(attribute, 'uk-') || Object(lang[\"startsWith\"])(attribute, 'data-uk-')\n        ? Object(lang[\"camelize\"])(attribute.replace('data-uk-', '').replace('uk-', ''))\n        : false;\n}\n\n// CONCATENATED MODULE: ./src/js/api/boot.js\n\n\n\n/* harmony default export */ var boot = (function (UIkit) {\n\n    const {connect, disconnect} = UIkit;\n\n    if (!('MutationObserver' in window)) {\n        return;\n    }\n\n    if (document.body) {\n\n        init();\n\n    } else {\n\n        (new MutationObserver(function () {\n\n            if (document.body) {\n                this.disconnect();\n                init();\n            }\n\n        })).observe(document, {childList: true, subtree: true});\n\n    }\n\n    function init() {\n\n        apply(document.body, connect);\n\n        fastdom.flush();\n\n        (new MutationObserver(mutations => mutations.forEach(applyMutation))).observe(document, {\n            childList: true,\n            subtree: true,\n            characterData: true,\n            attributes: true\n        });\n\n        UIkit._initialized = true;\n    }\n\n    function applyMutation(mutation) {\n\n        const {target, type} = mutation;\n\n        const update = type !== 'attributes'\n            ? applyChildList(mutation)\n            : applyAttribute(mutation);\n\n        update && UIkit.update(target);\n\n    }\n\n    function applyAttribute({target, attributeName}) {\n\n        if (attributeName === 'href') {\n            return true;\n        }\n\n        const name = getComponentName(attributeName);\n\n        if (!name || !(name in UIkit)) {\n            return;\n        }\n\n        if (hasAttr(target, attributeName)) {\n            UIkit[name](target);\n            return true;\n        }\n\n        const component = UIkit.getComponent(target, name);\n\n        if (component) {\n            component.$destroy();\n            return true;\n        }\n\n    }\n\n    function applyChildList({addedNodes, removedNodes}) {\n\n        for (let i = 0; i < addedNodes.length; i++) {\n            apply(addedNodes[i], connect);\n        }\n\n        for (let i = 0; i < removedNodes.length; i++) {\n            apply(removedNodes[i], disconnect);\n        }\n\n        return true;\n    }\n\n    function apply(node, fn) {\n\n        if (node.nodeType !== 1 || hasAttr(node, 'uk-no-boot')) {\n            return;\n        }\n\n        fn(node);\n        node = node.firstElementChild;\n        while (node) {\n            const next = node.nextElementSibling;\n            apply(node, fn);\n            node = next;\n        }\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/api/global.js\n\n\n/* harmony default export */ var global = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    UIkit.use = function (plugin) {\n\n        if (plugin.installed) {\n            return;\n        }\n\n        plugin.call(null, this);\n        plugin.installed = true;\n\n        return this;\n    };\n\n    UIkit.extend = function (options) {\n\n        options = options || {};\n\n        const Super = this;\n        const Sub = function UIkitComponent (options) {\n            this._init(options);\n        };\n\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.options = mergeOptions(Super.options, options);\n\n        Sub['super'] = Super;\n        Sub.extend = Super.extend;\n\n        return Sub;\n    };\n\n    UIkit.update = function (element, e) {\n\n        e = createEvent(e || 'update');\n        element = element ? Object(lang[\"toNode\"])(element) : document.body;\n\n        path(element).map(element => update(element[DATA], e));\n        dom_apply(element, element => update(element[DATA], e));\n\n    };\n\n    let container;\n    Object.defineProperty(UIkit, 'container', {\n\n        get() {\n            return container || document.body;\n        },\n\n        set(element) {\n            container = $(element);\n        }\n\n    });\n\n    function update(data, e) {\n\n        if (!data) {\n            return;\n        }\n\n        for (const name in data) {\n            if (data[name]._isReady) {\n                data[name]._callUpdate(e);\n            }\n        }\n\n    }\n\n    function path(element) {\n        const path = [];\n\n        while (element && element !== document.body && element.parentNode) {\n\n            element = element.parentNode;\n            path.unshift(element);\n\n        }\n\n        return path;\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/api/hooks.js\n\n\n/* harmony default export */ var hooks = (function (UIkit) {\n\n    UIkit.prototype._callHook = function (hook) {\n\n        const handlers = this.$options[hook];\n\n        if (handlers) {\n            handlers.forEach(handler => handler.call(this));\n        }\n    };\n\n    UIkit.prototype._callConnected = function () {\n\n        if (this._connected) {\n            return;\n        }\n\n        this._data = {};\n        this._initProps();\n\n        this._callHook('beforeConnect');\n        this._connected = true;\n\n        this._initEvents();\n        this._initObserver();\n\n        this._callHook('connected');\n\n        if (!this._isReady) {\n            ready(() => this._callReady());\n        }\n\n        this._callUpdate();\n    };\n\n    UIkit.prototype._callDisconnected = function () {\n\n        if (!this._connected) {\n            return;\n        }\n\n        this._callHook('beforeDisconnect');\n\n        if (this._observer) {\n            this._observer.disconnect();\n            this._observer = null;\n        }\n\n        this._unbindEvents();\n        this._callHook('disconnected');\n\n        this._connected = false;\n\n    };\n\n    UIkit.prototype._callReady = function () {\n\n        if (this._isReady) {\n            return;\n        }\n\n        this._isReady = true;\n        this._callHook('ready');\n        this._resetComputeds();\n        this._callUpdate();\n    };\n\n    UIkit.prototype._callUpdate = function (e) {\n\n        e = createEvent(e || 'update');\n\n        const {type} = e;\n\n        if (Object(lang[\"includes\"])(['update', 'load', 'resize'], type)) {\n            this._resetComputeds();\n        }\n\n        const updates = this.$options.update;\n        const {reads, writes} = this._frames;\n\n        if (!updates) {\n            return;\n        }\n\n        updates.forEach(({read, write, events}, i) => {\n\n            if (type !== 'update' && !Object(lang[\"includes\"])(events, type)) {\n                return;\n            }\n\n            if (read && !Object(lang[\"includes\"])(fastdom.reads, reads[i])) {\n                reads[i] = fastdom.read(() => {\n\n                    const result = read.call(this, this._data, e);\n\n                    if (result === false && write) {\n                        fastdom.clear(writes[i]);\n                        delete writes[i];\n                    } else if (Object(lang[\"isPlainObject\"])(result)) {\n                        Object(lang[\"assign\"])(this._data, result);\n                    }\n                    delete reads[i];\n                });\n            }\n\n            if (write && !Object(lang[\"includes\"])(fastdom.writes, writes[i])) {\n                writes[i] = fastdom.write(() => {\n                    write.call(this, this._data, e);\n                    delete writes[i];\n                });\n            }\n\n        });\n\n    };\n\n});\n\n// CONCATENATED MODULE: ./src/js/api/state.js\n\n\n/* harmony default export */ var api_state = (function (UIkit) {\n\n    let uid = 0;\n\n    UIkit.prototype._init = function (options) {\n\n        options = options || {};\n        options.data = normalizeData(options, this.constructor.options);\n\n        this.$options = mergeOptions(this.constructor.options, options, this);\n        this.$el = null;\n        this.$props = {};\n\n        this._frames = {reads: {}, writes: {}};\n        this._events = [];\n\n        this._uid = uid++;\n        this._initData();\n        this._initMethods();\n        this._initComputeds();\n        this._callHook('created');\n\n        if (options.el) {\n            this.$mount(options.el);\n        }\n    };\n\n    UIkit.prototype._initData = function () {\n\n        const {data = {}} = this.$options;\n\n        for (const key in data) {\n            this.$props[key] = this[key] = data[key];\n        }\n    };\n\n    UIkit.prototype._initMethods = function () {\n\n        const {methods} = this.$options;\n\n        if (methods) {\n            for (const key in methods) {\n                this[key] = Object(lang[\"bind\"])(methods[key], this);\n            }\n        }\n    };\n\n    UIkit.prototype._initComputeds = function () {\n\n        const {computed} = this.$options;\n\n        this._resetComputeds();\n\n        if (computed) {\n            for (const key in computed) {\n                registerComputed(this, key, computed[key]);\n            }\n        }\n    };\n\n    UIkit.prototype._resetComputeds = function () {\n        this._computeds = {};\n    };\n\n    UIkit.prototype._initProps = function (props) {\n\n        let key;\n\n        this._resetComputeds();\n\n        props = props || getProps(this.$options, this.$name);\n\n        for (key in props) {\n            if (!Object(lang[\"isUndefined\"])(props[key])) {\n                this.$props[key] = props[key];\n            }\n        }\n\n        const exclude = [this.$options.computed, this.$options.methods];\n        for (key in this.$props) {\n            if (key in props && notIn(exclude, key)) {\n                this[key] = this.$props[key];\n            }\n        }\n    };\n\n    UIkit.prototype._initEvents = function () {\n\n        const {events} = this.$options;\n\n        if (events) {\n\n            events.forEach(event => {\n\n                if (!Object(lang[\"hasOwn\"])(event, 'handler')) {\n                    for (const key in event) {\n                        registerEvent(this, event[key], key);\n                    }\n                } else {\n                    registerEvent(this, event);\n                }\n\n            });\n        }\n    };\n\n    UIkit.prototype._unbindEvents = function () {\n        this._events.forEach(unbind => unbind());\n        this._events = [];\n    };\n\n    UIkit.prototype._initObserver = function () {\n\n        let {attrs, props, el} = this.$options;\n        if (this._observer || !props || !attrs) {\n            return;\n        }\n\n        attrs = Object(lang[\"isArray\"])(attrs) ? attrs : Object.keys(props).map(key => Object(lang[\"hyphenate\"])(key));\n\n        this._observer = new MutationObserver(() => {\n\n            const data = getProps(this.$options, this.$name);\n            if (attrs.some(key => !Object(lang[\"isUndefined\"])(data[key]) && data[key] !== this.$props[key])) {\n                this.$reset();\n            }\n\n        });\n\n        this._observer.observe(el, {attributes: true, attributeFilter: attrs.concat([this.$name, `data-${this.$name}`])});\n    };\n\n    function getProps(opts, name) {\n\n        const data = {};\n        const {args = [], props = {}, el} = opts;\n\n        if (!props) {\n            return data;\n        }\n\n        for (const key in props) {\n            const prop = Object(lang[\"hyphenate\"])(key);\n            if (hasAttr(el, prop)) {\n\n                const value = coerce(props[key], attr_attr(el, prop));\n\n                if (prop === 'target' && (!value || Object(lang[\"startsWith\"])(value, '_'))) {\n                    continue;\n                }\n\n                data[key] = value;\n            }\n        }\n\n        const options = parseOptions(attr_data(el, name), args);\n\n        for (const key in options) {\n            const prop = Object(lang[\"camelize\"])(key);\n            if (props[prop] !== undefined) {\n                data[prop] = coerce(props[prop], options[key]);\n            }\n        }\n\n        return data;\n    }\n\n    function registerComputed(component, key, cb) {\n        Object.defineProperty(component, key, {\n\n            enumerable: true,\n\n            get() {\n\n                const {_computeds, $props, $el} = component;\n\n                if (!Object(lang[\"hasOwn\"])(_computeds, key)) {\n                    _computeds[key] = cb.call(component, $props, $el);\n                }\n\n                return _computeds[key];\n            },\n\n            set(value) {\n                component._computeds[key] = value;\n            }\n\n        });\n    }\n\n    function registerEvent(component, event, key) {\n\n        if (!Object(lang[\"isPlainObject\"])(event)) {\n            event = ({name: key, handler: event});\n        }\n\n        let {name, el, handler, capture, delegate, filter, self} = event;\n        el = Object(lang[\"isFunction\"])(el)\n            ? el.call(component)\n            : el || component.$el;\n\n        if (Object(lang[\"isArray\"])(el)) {\n            el.forEach(el => registerEvent(component, Object(lang[\"assign\"])({}, event, {el}), key));\n            return;\n        }\n\n        if (!el || filter && !filter.call(component)) {\n            return;\n        }\n\n        handler = detail(Object(lang[\"isString\"])(handler) ? component[handler] : Object(lang[\"bind\"])(handler, component));\n\n        if (self) {\n            handler = selfFilter(handler);\n        }\n\n        component._events.push(\n            on(\n                el,\n                name,\n                !delegate\n                    ? null\n                    : Object(lang[\"isString\"])(delegate)\n                        ? delegate\n                        : delegate.call(component),\n                handler,\n                capture\n            )\n        );\n\n    }\n\n    function selfFilter(handler) {\n        return function selfHandler(e) {\n            if (e.target === e.currentTarget || e.target === e.current) {\n                return handler.call(null, e);\n            }\n        };\n    }\n\n    function notIn(options, key) {\n        return options.every(arr => !arr || !Object(lang[\"hasOwn\"])(arr, key));\n    }\n\n    function detail(listener) {\n        return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n    }\n\n    function coerce(type, value) {\n\n        if (type === Boolean) {\n            return Object(lang[\"toBoolean\"])(value);\n        } else if (type === Number) {\n            return Object(lang[\"toNumber\"])(value);\n        } else if (type === 'list') {\n            return Object(lang[\"toList\"])(value);\n        } else if (type === 'media') {\n            return toMedia(value);\n        }\n\n        return type ? type(value) : value;\n    }\n\n    function toMedia(value) {\n\n        if (Object(lang[\"isString\"])(value)) {\n            if (value[0] === '@') {\n                const name = `media-${value.substr(1)}`;\n                value = Object(lang[\"toFloat\"])(getCssVar(name));\n            } else if (isNaN(value)) {\n                return value;\n            }\n        }\n\n        return value && !isNaN(value) ? `(min-width: ${value}px)` : false;\n    }\n\n    function normalizeData({data, el}, {args, props = {}}) {\n        data = Object(lang[\"isArray\"])(data)\n            ? args && args.length\n                ? data.slice(0, args.length).reduce((data, value, index) => {\n                    if (Object(lang[\"isPlainObject\"])(value)) {\n                        Object(lang[\"assign\"])(data, value);\n                    } else {\n                        data[args[index]] = value;\n                    }\n                    return data;\n                }, {})\n                : undefined\n            : data;\n\n        if (data) {\n            for (const key in data) {\n                if (Object(lang[\"isUndefined\"])(data[key])) {\n                    delete data[key];\n                } else {\n                    data[key] = props[key] ? coerce(props[key], data[key], el) : data[key];\n                }\n            }\n        }\n\n        return data;\n    }\n});\n\n// CONCATENATED MODULE: ./src/js/api/instance.js\n\n\n/* harmony default export */ var instance = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    UIkit.prototype.$mount = function (el) {\n\n        const {name} = this.$options;\n\n        if (!el[DATA]) {\n            el[DATA] = {};\n        }\n\n        if (el[DATA][name]) {\n            return;\n        }\n\n        el[DATA][name] = this;\n\n        this.$el = this.$options.el = this.$options.el || el;\n\n        this._callHook('init');\n\n        if (within(el, document)) {\n            this._callConnected();\n        }\n    };\n\n    UIkit.prototype.$emit = function (e) {\n        this._callUpdate(e);\n    };\n\n    UIkit.prototype.$reset = function () {\n        this._callDisconnected();\n        this._callConnected();\n    };\n\n    UIkit.prototype.$destroy = function (removeEl = false) {\n\n        const {el, name} = this.$options;\n\n        if (el) {\n            this._callDisconnected();\n        }\n\n        this._callHook('destroy');\n\n        if (!el || !el[DATA]) {\n            return;\n        }\n\n        delete el[DATA][name];\n\n        if (!Object.keys(el[DATA]).length) {\n            delete el[DATA];\n        }\n\n        if (removeEl) {\n            remove(this.$el);\n        }\n    };\n\n    UIkit.prototype.$create = function (component, element, data) {\n        return UIkit[component](element, data);\n    };\n\n    UIkit.prototype.$update = UIkit.update;\n    UIkit.prototype.$getComponent = UIkit.getComponent;\n\n    const names = {};\n    Object.defineProperties(UIkit.prototype, {\n\n        $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),\n\n        $name: {\n\n            get() {\n                const {name} = this.$options;\n\n                if (!names[name]) {\n                    names[name] = UIkit.prefix + Object(lang[\"hyphenate\"])(name);\n                }\n\n                return names[name];\n            }\n\n        }\n\n    });\n\n});\n\n// CONCATENATED MODULE: ./src/js/api/index.js\n\n\n\n\n\n\n\nconst api_UIkit = function (options) {\n    this._init(options);\n};\n\napi_UIkit.util = util_namespaceObject;\napi_UIkit.data = '__uikit__';\napi_UIkit.prefix = 'uk-';\napi_UIkit.options = {};\n\nglobal(api_UIkit);\nhooks(api_UIkit);\napi_state(api_UIkit);\napi_component(api_UIkit);\ninstance(api_UIkit);\n\n/* harmony default export */ var api = (api_UIkit);\n\n// CONCATENATED MODULE: ./src/js/mixin/class.js\n\n\n/* harmony default export */ var mixin_class = ({\n\n    connected() {\n        addClass(this.$el, this.$name);\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/mixin/togglable.js\n\n\n/* harmony default export */ var togglable = ({\n\n    props: {\n        cls: Boolean,\n        animation: 'list',\n        duration: Number,\n        origin: String,\n        transition: String,\n        queued: Boolean\n    },\n\n    data: {\n        cls: false,\n        animation: [false],\n        duration: 200,\n        origin: false,\n        transition: 'linear',\n        queued: false,\n\n        initProps: {\n            overflow: '',\n            height: '',\n            paddingTop: '',\n            paddingBottom: '',\n            marginTop: '',\n            marginBottom: ''\n        },\n\n        hideProps: {\n            overflow: 'hidden',\n            height: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            marginTop: 0,\n            marginBottom: 0\n        }\n\n    },\n\n    computed: {\n\n        hasAnimation({animation}) {\n            return !!animation[0];\n        },\n\n        hasTransition({animation}) {\n            return this.hasAnimation && animation[0] === true;\n        }\n\n    },\n\n    methods: {\n\n        toggleElement(targets, show, animate) {\n            return new util_promise[\"Promise\"](resolve => {\n\n                targets = Object(lang[\"toNodes\"])(targets);\n\n                const all = targets => util_promise[\"Promise\"].all(targets.map(el => this._toggleElement(el, show, animate)));\n                const toggled = targets.filter(el => this.isToggled(el));\n                const untoggled = targets.filter(el => !Object(lang[\"includes\"])(toggled, el));\n\n                let p;\n\n                if (!this.queued || !Object(lang[\"isUndefined\"])(animate) || !Object(lang[\"isUndefined\"])(show) || !this.hasAnimation || targets.length < 2) {\n\n                    p = all(untoggled.concat(toggled));\n\n                } else {\n\n                    const {body} = document;\n                    const scroll = body.scrollTop;\n                    const [el] = toggled;\n                    const inProgress = Animation.inProgress(el) && hasClass(el, 'uk-animation-leave')\n                            || Transition.inProgress(el) && el.style.height === '0px';\n\n                    p = all(toggled);\n\n                    if (!inProgress) {\n                        p = p.then(() => {\n                            const p = all(untoggled);\n                            body.scrollTop = scroll;\n                            return p;\n                        });\n                    }\n\n                }\n\n                p.then(resolve, lang[\"noop\"]);\n\n            });\n        },\n\n        toggleNow(targets, show) {\n            return new util_promise[\"Promise\"](resolve => util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(targets).map(el => this._toggleElement(el, show, false))).then(resolve, lang[\"noop\"]));\n        },\n\n        isToggled(el) {\n            const nodes = Object(lang[\"toNodes\"])(el || this.$el);\n            return this.cls\n                ? hasClass(nodes, this.cls.split(' ')[0])\n                : !hasAttr(nodes, 'hidden');\n        },\n\n        updateAria(el) {\n            if (this.cls === false) {\n                attr_attr(el, 'aria-hidden', !this.isToggled(el));\n            }\n        },\n\n        _toggleElement(el, show, animate) {\n\n            show = Object(lang[\"isBoolean\"])(show)\n                ? show\n                : Animation.inProgress(el)\n                    ? hasClass(el, 'uk-animation-leave')\n                    : Transition.inProgress(el)\n                        ? el.style.height === '0px'\n                        : !this.isToggled(el);\n\n            if (!trigger(el, `before${show ? 'show' : 'hide'}`, [this])) {\n                return util_promise[\"Promise\"].reject();\n            }\n\n            const promise = (animate === false || !this.hasAnimation\n                ? this._toggleImmediate\n                : this.hasTransition\n                    ? this._toggleHeight\n                    : this._toggleAnimation\n            )(el, show);\n\n            trigger(el, show ? 'show' : 'hide', [this]);\n\n            return promise.then(() => {\n                trigger(el, show ? 'shown' : 'hidden', [this]);\n                this.$update();\n            });\n        },\n\n        _toggle(el, toggled) {\n\n            if (!el) {\n                return;\n            }\n\n            let changed;\n            if (this.cls) {\n                changed = Object(lang[\"includes\"])(this.cls, ' ') || Boolean(toggled) !== hasClass(el, this.cls);\n                changed && toggleClass(el, this.cls, Object(lang[\"includes\"])(this.cls, ' ') ? undefined : toggled);\n            } else {\n                changed = Boolean(toggled) === hasAttr(el, 'hidden');\n                changed && attr_attr(el, 'hidden', !toggled ? '' : null);\n            }\n\n            $$('[autofocus]', el).some(el => isVisible(el) && (el.focus() || true));\n\n            this.updateAria(el);\n            changed && this.$update();\n        },\n\n        _toggleImmediate(el, show) {\n            this._toggle(el, show);\n            return util_promise[\"Promise\"].resolve();\n        },\n\n        _toggleHeight(el, show) {\n\n            const inProgress = Transition.inProgress(el);\n            const inner = el.hasChildNodes ? Object(lang[\"toFloat\"])(style_css(el.firstElementChild, 'marginTop')) + Object(lang[\"toFloat\"])(style_css(el.lastElementChild, 'marginBottom')) : 0;\n            const currentHeight = isVisible(el) ? dimensions_height(el) + (inProgress ? 0 : inner) : 0;\n\n            Transition.cancel(el);\n\n            if (!this.isToggled(el)) {\n                this._toggle(el, true);\n            }\n\n            dimensions_height(el, '');\n\n            // Update child components first\n            fastdom.flush();\n\n            const endHeight = dimensions_height(el) + (inProgress ? 0 : inner);\n            dimensions_height(el, currentHeight);\n\n            return (show\n                ? Transition.start(el, Object(lang[\"assign\"])({}, this.initProps, {overflow: 'hidden', height: endHeight}), Math.round(this.duration * (1 - currentHeight / endHeight)), this.transition)\n                : Transition.start(el, this.hideProps, Math.round(this.duration * (currentHeight / endHeight)), this.transition).then(() => this._toggle(el, false))\n            ).then(() => style_css(el, this.initProps));\n\n        },\n\n        _toggleAnimation(el, show) {\n\n            Animation.cancel(el);\n\n            if (show) {\n                this._toggle(el, true);\n                return Animation.in(el, this.animation[0], this.duration, this.origin);\n            }\n\n            return Animation.out(el, this.animation[1] || this.animation[0], this.duration, this.origin).then(() => this._toggle(el, false));\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/accordion.js\n\n\n\n\n/* harmony default export */ var accordion = ({\n\n    mixins: [mixin_class, togglable],\n\n    props: {\n        targets: String,\n        active: null,\n        collapsible: Boolean,\n        multiple: Boolean,\n        toggle: String,\n        content: String,\n        transition: String\n    },\n\n    data: {\n        targets: '> *',\n        active: false,\n        animation: [true],\n        collapsible: true,\n        multiple: false,\n        clsOpen: 'uk-open',\n        toggle: '> .uk-accordion-title',\n        content: '> .uk-accordion-content',\n        transition: 'ease'\n    },\n\n    computed: {\n\n        items({targets}, $el) {\n            return $$(targets, $el);\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `${this.targets} ${this.$props.toggle}`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.toggle(dom_index($$(`${this.targets} ${this.$props.toggle}`, this.$el), e.current));\n            }\n\n        }\n\n    ],\n\n    connected() {\n\n        if (this.active === false) {\n            return;\n        }\n\n        const active = this.items[Number(this.active)];\n        if (active && !hasClass(active, this.clsOpen)) {\n            this.toggle(active, false);\n        }\n    },\n\n    update() {\n\n        this.items.forEach(el => this._toggleImmediate($(this.content, el), hasClass(el, this.clsOpen)));\n\n        const active = !this.collapsible && !hasClass(this.items, this.clsOpen) && this.items[0];\n        if (active) {\n            this.toggle(active, false);\n        }\n    },\n\n    methods: {\n\n        toggle(item, animate) {\n\n            const index = getIndex(item, this.items);\n            const active = filter_filter(this.items, `.${this.clsOpen}`);\n\n            item = this.items[index];\n\n            item && [item]\n                .concat(!this.multiple && !Object(lang[\"includes\"])(active, item) && active || [])\n                .forEach(el => {\n\n                    const isItem = el === item;\n                    const state = isItem && !hasClass(el, this.clsOpen);\n\n                    if (!state && isItem && !this.collapsible && active.length < 2) {\n                        return;\n                    }\n\n                    toggleClass(el, this.clsOpen, state);\n\n                    const content = el._wrapper ? el._wrapper.firstElementChild : $(this.content, el);\n\n                    if (!el._wrapper) {\n                        el._wrapper = wrapAll(content, '<div>');\n                        attr_attr(el._wrapper, 'hidden', state ? '' : null);\n                    }\n\n                    this._toggleImmediate(content, true);\n                    this.toggleElement(el._wrapper, state, animate).then(() => {\n                        if (hasClass(el, this.clsOpen) === state) {\n\n                            if (!state) {\n                                this._toggleImmediate(content, false);\n                            }\n\n                            el._wrapper = null;\n                            unwrap(content);\n                        }\n                    });\n\n                });\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/alert.js\n\n\n\n\n/* harmony default export */ var core_alert = ({\n\n    attrs: true,\n\n    mixins: [mixin_class, togglable],\n\n    args: 'animation',\n\n    props: {\n        close: String\n    },\n\n    data: {\n        animation: [true],\n        selClose: '.uk-alert-close',\n        duration: 150,\n        hideProps: Object(lang[\"assign\"])({opacity: 0}, togglable.data.hideProps)\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return this.selClose;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.close();\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        close() {\n            this.toggleElement(this.$el).then(() => this.$destroy(true));\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/core.js\n\n\n/* harmony default export */ var core = (function (UIkit) {\n\n    ready(() => {\n\n        let scroll = 0;\n        let started = 0;\n\n        on(window, 'load resize', e => UIkit.update(null, e));\n        on(window, 'scroll', e => {\n            e.dir = scroll <= window.scrollY ? 'down' : 'up';\n            e.scrollY = scroll = window.scrollY;\n            UIkit.update(null, e);\n        }, {capture: true, passive: false});\n\n        on(document, 'animationstart', ({target}) => {\n            if ((style_css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {\n\n                started++;\n                style_css(document.body, 'overflowX', 'hidden');\n                setTimeout(() => {\n                    if (!--started) {\n                        style_css(document.body, 'overflowX', '');\n                    }\n                }, Object(lang[\"toMs\"])(style_css(target, 'animationDuration')) + 100);\n            }\n        }, true);\n\n        if (!hasTouch) {\n            return;\n        }\n\n        const cls = 'uk-hover';\n\n        on(document, 'tap', ({target}) =>\n            $$(`.${cls}`).forEach(el =>\n                !within(target, el) && removeClass(el, cls)\n            )\n        );\n\n        Object.defineProperty(UIkit, 'hoverSelector', {\n\n            set(selector) {\n                on(document, 'tap', selector, ({current}) => addClass(current, cls));\n            }\n\n        });\n\n        UIkit.hoverSelector = '.uk-animation-toggle, .uk-transition-toggle, [uk-hover]';\n\n    });\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/video.js\n\n\n/* harmony default export */ var core_video = ({\n\n    args: 'autoplay',\n\n    props: {\n        automute: Boolean,\n        autoplay: Boolean,\n    },\n\n    data: {\n        automute: false,\n        autoplay: true\n    },\n\n    computed: {\n\n        inView({autoplay}) {\n            return autoplay === 'inview';\n        }\n\n    },\n\n    connected() {\n\n        if (this.inView && !hasAttr(this.$el, 'preload')) {\n            this.$el.preload = 'none';\n        }\n\n    },\n\n    ready() {\n\n        this.player = new player_Player(this.$el);\n\n        if (this.automute) {\n            this.player.mute();\n        }\n\n    },\n\n    update: [\n\n        {\n\n            read(_, {type}) {\n\n                return !this.player || (type === 'scroll' || type === 'resize') && !this.inView\n                    ? false\n                    : {\n                        visible: isVisible(this.$el) && style_css(this.$el, 'visibility') !== 'hidden',\n                        inView: this.inView && isInView(this.$el)\n                    };\n            },\n\n            write({visible, inView}) {\n\n                if (!visible || this.inView && !inView) {\n                    this.player.pause();\n                } else if (this.autoplay === true || this.inView && inView) {\n                    this.player.play();\n                }\n\n            },\n\n            events: ['load', 'resize', 'scroll']\n\n        }\n\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/cover.js\n\n\n\n\n/* harmony default export */ var cover = ({\n\n    mixins: [mixin_class, core_video],\n\n    props: {\n        width: Number,\n        height: Number\n    },\n\n    data: {\n        automute: true\n    },\n\n    update: {\n\n        write() {\n\n            const el = this.$el;\n\n            if (!isVisible(el)) {\n                return;\n            }\n\n            const {offsetHeight: height, offsetWidth: width} = el.parentNode;\n\n            style_css(\n                style_css(el, {width: '', height: ''}),\n                lang[\"Dimensions\"].cover(\n                    {\n                        width: this.width || el.clientWidth,\n                        height: this.height || el.clientHeight\n                    },\n                    {\n                        width: width + (width % 2 ? 1 : 0),\n                        height: height + (height % 2 ? 1 : 0)\n                    }\n                )\n            );\n\n        },\n\n        events: ['load', 'resize']\n\n    },\n\n    events: {\n\n        loadedmetadata() {\n            this.$emit();\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/mixin/position.js\n\n\n/* harmony default export */ var mixin_position = ({\n\n    props: {\n        pos: String,\n        offset: null,\n        flip: Boolean,\n        clsPos: String\n    },\n\n    data: {\n        pos: `bottom-${!isRtl ? 'left' : 'right'}`,\n        flip: true,\n        offset: false,\n        clsPos: ''\n    },\n\n    computed: {\n\n        pos({pos}) {\n            return (pos + (!Object(lang[\"includes\"])(pos, '-') ? '-center' : '')).split('-');\n        },\n\n        dir() {\n            return this.pos[0];\n        },\n\n        align() {\n            return this.pos[1];\n        }\n\n    },\n\n    methods: {\n\n        positionAt(element, target, boundary) {\n\n            removeClasses(element, `${this.clsPos}-(top|bottom|left|right)(-[a-z]+)?`);\n            style_css(element, {top: '', left: ''});\n\n            let node;\n            let {offset} = this;\n\n            offset = Object(lang[\"isNumeric\"])(offset)\n                ? offset\n                : (node = $(offset))\n                    ? dimensions_offset(node)[axis === 'x' ? 'left' : 'top'] - dimensions_offset(target)[axis === 'x' ? 'right' : 'bottom']\n                    : 0;\n\n            const axis = this.getAxis();\n            const {x, y} = positionAt(\n                element,\n                target,\n                axis === 'x' ? `${flipPosition(this.dir)} ${this.align}` : `${this.align} ${flipPosition(this.dir)}`,\n                axis === 'x' ? `${this.dir} ${this.align}` : `${this.align} ${this.dir}`,\n                axis === 'x' ? `${this.dir === 'left' ? -offset : offset}` : ` ${this.dir === 'top' ? -offset : offset}`,\n                null,\n                this.flip,\n                boundary\n            ).target;\n\n            this.dir = axis === 'x' ? x : y;\n            this.align = axis === 'x' ? y : x;\n\n            toggleClass(element, `${this.clsPos}-${this.dir}-${this.align}`, this.offset === false);\n\n        },\n\n        getAxis() {\n            return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/drop.js\n\n\n\n\nlet drop_active;\n\n/* harmony default export */ var core_drop = ({\n\n    mixins: [mixin_position, togglable],\n\n    args: 'pos',\n\n    props: {\n        mode: 'list',\n        toggle: Boolean,\n        boundary: Boolean,\n        boundaryAlign: Boolean,\n        delayShow: Number,\n        delayHide: Number,\n        clsDrop: String\n    },\n\n    data: {\n        mode: ['click', 'hover'],\n        toggle: true,\n        boundary: window,\n        boundaryAlign: false,\n        delayShow: 0,\n        delayHide: 800,\n        clsDrop: false,\n        hoverIdle: 200,\n        animation: ['uk-animation-fade'],\n        cls: 'uk-open'\n    },\n\n    computed: {\n\n        boundary({boundary}, $el) {\n            return query(boundary, $el);\n        },\n\n        clsDrop({clsDrop}) {\n            return clsDrop || `uk-${this.$options.name}`;\n        },\n\n        clsPos() {\n            return this.clsDrop;\n        }\n\n    },\n\n    init() {\n        this.tracker = new MouseTracker();\n    },\n\n    connected() {\n\n        addClass(this.$el, this.clsDrop);\n\n        const {toggle} = this.$props;\n        this.toggle = toggle && this.$create('toggle', Object(lang[\"isString\"])(toggle) ? query(toggle, this.$el) : this.$el.previousElementSibling, {\n            target: this.$el,\n            mode: this.mode\n        });\n\n        this.updateAria(this.$el);\n\n    },\n\n    events: [\n\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `.${this.clsDrop}-close`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.hide(false);\n            }\n\n        },\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return 'a[href^=\"#\"]';\n            },\n\n            handler(e) {\n\n                if (e.defaultPrevented) {\n                    return;\n                }\n\n                const id = e.target.hash;\n\n                if (!id) {\n                    e.preventDefault();\n                }\n\n                if (!id || !within(id, this.$el)) {\n                    this.hide(false);\n                }\n            }\n\n        },\n\n        {\n\n            name: 'beforescroll',\n\n            handler() {\n                this.hide(false);\n            }\n\n        },\n\n        {\n\n            name: 'toggle',\n\n            self: true,\n\n            handler(e, toggle) {\n\n                e.preventDefault();\n\n                if (this.isToggled()) {\n                    this.hide(false);\n                } else {\n                    this.show(toggle, false);\n                }\n            }\n\n        },\n\n        {\n\n            name: pointerEnter,\n\n            filter() {\n                return Object(lang[\"includes\"])(this.mode, 'hover');\n            },\n\n            handler(e) {\n\n                if (isTouch(e)) {\n                    return;\n                }\n\n                if (drop_active\n                    && drop_active !== this\n                    && drop_active.toggle\n                    && Object(lang[\"includes\"])(drop_active.toggle.mode, 'hover')\n                    && !within(e.target, drop_active.toggle.$el)\n                    && !Object(lang[\"pointInRect\"])({x: e.pageX, y: e.pageY}, dimensions_offset(drop_active.$el))\n                ) {\n                    drop_active.hide(false);\n                }\n\n                e.preventDefault();\n                this.show(this.toggle);\n            }\n\n        },\n\n        {\n\n            name: 'toggleshow',\n\n            handler(e, toggle) {\n\n                if (toggle && !Object(lang[\"includes\"])(toggle.target, this.$el)) {\n                    return;\n                }\n\n                e.preventDefault();\n                this.show(toggle || this.toggle);\n            }\n\n        },\n\n        {\n\n            name: `togglehide ${pointerLeave}`,\n\n            handler(e, toggle) {\n\n                if (isTouch(e) || toggle && !Object(lang[\"includes\"])(toggle.target, this.$el)) {\n                    return;\n                }\n\n                e.preventDefault();\n\n                if (this.toggle && Object(lang[\"includes\"])(this.toggle.mode, 'hover')) {\n                    this.hide();\n                }\n            }\n\n        },\n\n        {\n\n            name: 'beforeshow',\n\n            self: true,\n\n            handler() {\n                this.clearTimers();\n                Animation.cancel(this.$el);\n                this.position();\n            }\n\n        },\n\n        {\n\n            name: 'show',\n\n            self: true,\n\n            handler() {\n                this.tracker.init();\n                if (this.toggle) {\n                    addClass(this.toggle.$el, this.cls);\n                    attr_attr(this.toggle.$el, 'aria-expanded', 'true');\n                }\n                drop_registerEvent();\n            }\n\n        },\n\n        {\n\n            name: 'beforehide',\n\n            self: true,\n\n            handler() {\n                this.clearTimers();\n            }\n\n        },\n\n        {\n\n            name: 'hide',\n\n            handler({target}) {\n\n                if (this.$el !== target) {\n                    drop_active = drop_active === null && within(target, this.$el) && this.isToggled() ? this : drop_active;\n                    return;\n                }\n\n                drop_active = this.isActive() ? null : drop_active;\n\n                if (this.toggle) {\n                    removeClass(this.toggle.$el, this.cls);\n                    attr_attr(this.toggle.$el, 'aria-expanded', 'false');\n                    this.toggle.$el.blur();\n                    $$('a, button', this.toggle.$el).forEach(el => el.blur());\n                }\n\n                this.tracker.cancel();\n            }\n\n        }\n\n    ],\n\n    update: {\n\n        write() {\n\n            if (this.isToggled() && !Animation.inProgress(this.$el)) {\n                this.position();\n            }\n\n        },\n\n        events: ['resize']\n\n    },\n\n    methods: {\n\n        show(toggle, delay = true) {\n\n            const show = () => !this.isToggled() && this.toggleElement(this.$el, true);\n            const tryShow = () => {\n\n                this.toggle = toggle || this.toggle;\n\n                this.clearTimers();\n\n                if (this.isActive()) {\n                    return;\n                } else if (delay && drop_active && drop_active !== this && drop_active.isDelaying) {\n                    this.showTimer = setTimeout(this.show, 10);\n                    return;\n                } else if (this.isParentOf(drop_active)) {\n\n                    if (drop_active.hideTimer) {\n                        drop_active.hide(false);\n                    } else {\n                        return;\n                    }\n\n                } else if (drop_active && !this.isChildOf(drop_active) && !this.isParentOf(drop_active)) {\n\n                    let prev;\n                    while (drop_active && drop_active !== prev && !this.isChildOf(drop_active)) {\n                        prev = drop_active;\n                        drop_active.hide(false);\n                    }\n\n                }\n\n                if (delay && this.delayShow) {\n                    this.showTimer = setTimeout(show, this.delayShow);\n                } else {\n                    show();\n                }\n\n                drop_active = this;\n            };\n\n            if (toggle && this.toggle && toggle.$el !== this.toggle.$el) {\n\n                once(this.$el, 'hide', tryShow);\n                this.hide(false);\n\n            } else {\n                tryShow();\n            }\n        },\n\n        hide(delay = true) {\n\n            const hide = () => this.toggleNow(this.$el, false);\n\n            this.clearTimers();\n\n            this.isDelaying = this.tracker.movesTo(this.$el);\n\n            if (delay && this.isDelaying) {\n                this.hideTimer = setTimeout(this.hide, this.hoverIdle);\n            } else if (delay && this.delayHide) {\n                this.hideTimer = setTimeout(hide, this.delayHide);\n            } else {\n                hide();\n            }\n        },\n\n        clearTimers() {\n            clearTimeout(this.showTimer);\n            clearTimeout(this.hideTimer);\n            this.showTimer = null;\n            this.hideTimer = null;\n            this.isDelaying = false;\n        },\n\n        isActive() {\n            return drop_active === this;\n        },\n\n        isChildOf(drop) {\n            return drop && drop !== this && within(this.$el, drop.$el);\n        },\n\n        isParentOf(drop) {\n            return drop && drop !== this && within(drop.$el, this.$el);\n        },\n\n        position() {\n\n            removeClasses(this.$el, `${this.clsDrop}-(stack|boundary)`);\n            style_css(this.$el, {top: '', left: '', display: 'block'});\n            toggleClass(this.$el, `${this.clsDrop}-boundary`, this.boundaryAlign);\n\n            const boundary = dimensions_offset(this.boundary);\n            const alignTo = this.boundaryAlign ? boundary : dimensions_offset(this.toggle.$el);\n\n            if (this.align === 'justify') {\n                const prop = this.getAxis() === 'y' ? 'width' : 'height';\n                style_css(this.$el, prop, alignTo[prop]);\n            } else if (this.$el.offsetWidth > Math.max(boundary.right - alignTo.left, alignTo.right - boundary.left)) {\n                addClass(this.$el, `${this.clsDrop}-stack`);\n            }\n\n            this.positionAt(this.$el, this.boundaryAlign ? this.boundary : this.toggle.$el, this.boundary);\n\n            style_css(this.$el, 'display', '');\n\n        }\n\n    }\n\n});\n\nlet registered;\n\nfunction drop_registerEvent() {\n\n    if (registered) {\n        return;\n    }\n\n    registered = true;\n    on(document, 'click', ({target, defaultPrevented}) => {\n        let prev;\n\n        if (defaultPrevented) {\n            return;\n        }\n\n        while (drop_active && drop_active !== prev && !within(target, drop_active.$el) && !(drop_active.toggle && within(target, drop_active.toggle.$el))) {\n            prev = drop_active;\n            drop_active.hide(false);\n        }\n    });\n}\n\n// CONCATENATED MODULE: ./src/js/core/dropdown.js\n\n\n/* harmony default export */ var core_dropdown = ({\n\n    extends: core_drop\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/form-custom.js\n\n\n\n/* harmony default export */ var form_custom = ({\n\n    mixins: [mixin_class],\n\n    args: 'target',\n\n    props: {\n        target: Boolean\n    },\n\n    data: {\n        target: false\n    },\n\n    computed: {\n\n        input(_, $el) {\n            return $(selInput, $el);\n        },\n\n        state() {\n            return this.input.nextElementSibling;\n        },\n\n        target({target}, $el) {\n            return target && (target === true\n                && this.input.parentNode === $el\n                && this.input.nextElementSibling\n                || query(target, $el));\n        }\n\n    },\n\n    update() {\n\n        const {target, input} = this;\n\n        if (!target) {\n            return;\n        }\n\n        let option;\n        const prop = isInput(target) ? 'value' : 'textContent';\n        const prev = target[prop];\n        const value = input.files && input.files[0]\n            ? input.files[0].name\n            : selector_matches(input, 'select') && (option = $$('option', input).filter(el => el.selected)[0])\n                ? option.textContent\n                : input.value;\n\n        if (prev !== value) {\n            target[prop] = value;\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'focusin focusout mouseenter mouseleave',\n\n            delegate: selInput,\n\n            handler({type, current}) {\n                if (current === this.input) {\n                    toggleClass(\n                        this.state,\n                        `uk-${Object(lang[\"includes\"])(type, 'focus') ? 'focus' : 'hover'}`,\n                        Object(lang[\"includes\"])(['focusin', 'mouseenter'], type)\n                    );\n                }\n            }\n\n        },\n\n        {\n\n            name: 'change',\n\n            handler() {\n                this.$emit();\n            }\n\n        }\n\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/gif.js\n\n\n// Deprecated\n/* harmony default export */ var gif = ({\n\n    update: {\n\n        read(data) {\n\n            const inview = isInView(this.$el);\n\n            if (!inview || data.isInView === inview) {\n                return false;\n            }\n\n            data.isInView = inview;\n        },\n\n        write() {\n            this.$el.src = this.$el.src;\n        },\n\n        events: ['scroll', 'load', 'resize']\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/margin.js\n\n\n/* harmony default export */ var margin = ({\n\n    props: {\n        margin: String,\n        firstColumn: Boolean\n    },\n\n    data: {\n        margin: 'uk-margin-small-top',\n        firstColumn: 'uk-first-column'\n    },\n\n    update: {\n\n        read(data) {\n\n            const items = this.$el.children;\n            const rows = [[]];\n\n            if (!items.length || !isVisible(this.$el)) {\n                return data.rows = rows;\n            }\n\n            data.rows = getRows(items);\n            data.stacks = !data.rows.some(row => row.length > 1);\n\n        },\n\n        write({rows}) {\n\n            rows.forEach((row, i) =>\n                row.forEach((el, j) => {\n                    toggleClass(el, this.margin, i !== 0);\n                    toggleClass(el, this.firstColumn, j === 0);\n                })\n            );\n\n        },\n\n        events: ['load', 'resize']\n\n    }\n\n});\n\nfunction getRows(items) {\n    const rows = [[]];\n\n    for (let i = 0; i < items.length; i++) {\n\n        const el = items[i];\n        const dim = getOffset(el);\n\n        if (!dim.height) {\n            continue;\n        }\n\n        for (let j = rows.length - 1; j >= 0; j--) {\n\n            const row = rows[j];\n\n            if (!row[0]) {\n                row.push(el);\n                break;\n            }\n\n            const leftDim = getOffset(row[0]);\n\n            if (dim.top >= Math.floor(leftDim.bottom)) {\n                rows.push([el]);\n                break;\n            }\n\n            if (Math.floor(dim.bottom) > leftDim.top) {\n\n                if (dim.left < leftDim.left && !isRtl) {\n                    row.unshift(el);\n                    break;\n                }\n\n                row.push(el);\n                break;\n            }\n\n            if (j === 0) {\n                rows.unshift([el]);\n                break;\n            }\n\n        }\n\n    }\n\n    return rows;\n\n}\n\nfunction getOffset(element) {\n\n    const {offsetTop, offsetLeft, offsetHeight} = element;\n\n    return {\n        top: offsetTop,\n        left: offsetLeft,\n        height: offsetHeight,\n        bottom: offsetTop + offsetHeight\n    };\n}\n\n// CONCATENATED MODULE: ./src/js/core/grid.js\n\n\n\n\n/* harmony default export */ var grid = ({\n\n    extends: margin,\n\n    mixins: [mixin_class],\n\n    attrs: true,\n\n    name: 'grid',\n\n    props: {\n        masonry: Boolean,\n        parallax: Number\n    },\n\n    data: {\n        margin: 'uk-grid-margin',\n        clsStack: 'uk-grid-stack',\n        masonry: false,\n        parallax: 0\n    },\n\n    computed: {\n\n        parallax({parallax}) {\n            return Math.abs(parallax);\n        }\n\n    },\n\n    connected() {\n        this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');\n    },\n\n    update: [\n\n        {\n\n            read({rows}) {\n\n                if (this.masonry || this.parallax) {\n                    rows = rows.map(elements => Object(lang[\"sortBy\"])(elements, 'offsetLeft'));\n                }\n\n                let translates = false;\n                let elHeight = false;\n\n                if (this.masonry) {\n\n                    let height = 0;\n\n                    translates = rows.reduce((translates, row, i) => {\n\n                        translates[i] = row.map((_, j) => i === 0 ? 0 : Object(lang[\"toFloat\"])(translates[i - 1][j]) + (height - Object(lang[\"toFloat\"])(rows[i - 1][j] && rows[i - 1][j].offsetHeight)));\n                        height = row.reduce((height, el) => Math.max(height, el.offsetHeight), 0);\n\n                        return translates;\n\n                    }, []);\n\n                    elHeight = maxColumnHeight(rows) + getMarginTop(this.$el, this.margin) * (rows.length - 1);\n\n                }\n\n                return {rows, translates, height: elHeight};\n\n            },\n\n            write({rows, stacks, height}) {\n\n                toggleClass(this.$el, this.clsStack, stacks);\n\n                style_css(this.$el, 'paddingBottom', this.parallax && rows.some(row => row.length > 1) ? this.parallax : '');\n\n                height && style_css(this.$el, 'height', height);\n\n            },\n\n            events: ['load', 'resize']\n\n        },\n\n        {\n\n            read({rows, height}) {\n                return {\n                    scrolled: this.parallax && rows.some(row => row.length > 1)\n                        ? scrolledOver(this.$el, height ? height - dimensions_height(this.$el) : 0) * this.parallax\n                        : false\n                };\n            },\n\n            write({rows, scrolled, translates}) {\n\n                if (scrolled === false && !translates) {\n                    return;\n                }\n\n                rows.forEach((row, i) =>\n                    row.forEach((el, j) =>\n                        style_css(el, 'transform', !scrolled && !translates ? '' : `translateY(${\n                            (translates && -translates[i][j]) + (scrolled ? j % 2 ? scrolled : scrolled / 8 : 0)\n                        }px)`)\n                    )\n                );\n\n            },\n\n            events: ['scroll', 'load', 'resize']\n\n        }\n\n    ]\n\n});\n\nfunction getMarginTop(root, cls) {\n\n    const nodes = Object(lang[\"toNodes\"])(root.children);\n    const [node] = nodes.filter(el => hasClass(el, cls));\n\n    return Object(lang[\"toFloat\"])(node\n        ? style_css(node, 'marginTop')\n        : style_css(nodes[0], 'paddingLeft'));\n}\n\nfunction maxColumnHeight(rows) {\n    return Math.max(...rows.reduce((sum, row) => {\n        row.forEach((el, i) => sum[i] = (sum[i] || 0) + el.offsetHeight);\n        return sum;\n    }, []));\n}\n\n// CONCATENATED MODULE: ./src/js/core/height-match.js\n\n\n\n/* harmony default export */ var height_match = ({\n\n    args: 'target',\n\n    props: {\n        target: String,\n        row: Boolean\n    },\n\n    data: {\n        target: '> *',\n        row: true\n    },\n\n    computed: {\n\n        elements({target}, $el) {\n            return $$(target, $el);\n        }\n\n    },\n\n    update: {\n\n        read() {\n\n            style_css(this.elements, {\n                minHeight: '',\n                boxSizing: ''\n            });\n\n            return {\n                rows: !this.row\n                    ? [this.match(this.elements)]\n                    : getRows(this.elements).map(elements => this.match(elements))\n            };\n        },\n\n        write({rows}) {\n\n            rows.forEach(({height, elements}) => style_css(elements, {\n                minHeight: height,\n                boxSizing: 'border-box'\n            }));\n\n        },\n\n        events: ['load', 'resize']\n\n    },\n\n    methods: {\n\n        match(elements) {\n\n            if (elements.length < 2) {\n                return {};\n            }\n\n            const heights = [];\n            let max = 0;\n\n            elements\n                .forEach(el => {\n                    const {height} = dimensions_offset(el);\n                    max = Math.max(max, height);\n                    heights.push(height);\n                });\n\n            elements = elements.filter((el, i) => heights[i] < max);\n\n            return {height: max, elements};\n        }\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/height-viewport.js\n\n\n/* harmony default export */ var height_viewport = ({\n\n    props: {\n        expand: Boolean,\n        offsetTop: Boolean,\n        offsetBottom: Boolean,\n        minHeight: Number\n    },\n\n    data: {\n        expand: false,\n        offsetTop: false,\n        offsetBottom: false,\n        minHeight: 0\n    },\n\n    update: {\n\n        write() {\n\n            style_css(this.$el, 'boxSizing', 'border-box');\n\n            const viewport = dimensions_height(window);\n            let minHeight, offsetTop = 0;\n\n            if (this.expand) {\n\n                style_css(this.$el, {height: '', minHeight: ''});\n\n                const diff = viewport - offsetHeight(document.documentElement);\n\n                if (diff > 0) {\n                    minHeight = offsetHeight(this.$el) + diff;\n                }\n\n            } else {\n\n                const {top} = dimensions_offset(this.$el);\n\n                if (top < viewport / 2 && this.offsetTop) {\n                    offsetTop += top;\n                }\n\n                if (this.offsetBottom === true) {\n\n                    offsetTop += offsetHeight(this.$el.nextElementSibling);\n\n                } else if (Object(lang[\"isNumeric\"])(this.offsetBottom)) {\n\n                    offsetTop += (viewport / 100) * this.offsetBottom;\n\n                } else if (this.offsetBottom && Object(lang[\"endsWith\"])(this.offsetBottom, 'px')) {\n\n                    offsetTop += Object(lang[\"toFloat\"])(this.offsetBottom);\n\n                } else if (Object(lang[\"isString\"])(this.offsetBottom)) {\n\n                    offsetTop += offsetHeight(query(this.offsetBottom, this.$el));\n\n                }\n\n                // on mobile devices (iOS and Android) window.innerHeight !== 100vh\n                minHeight = offsetTop ? `calc(100vh - ${offsetTop}px)` : '100vh';\n\n            }\n\n            if (!minHeight) {\n                return;\n            }\n\n            style_css(this.$el, {height: '', minHeight});\n\n            const elHeight = this.$el.offsetHeight;\n            if (this.minHeight && this.minHeight > elHeight) {\n                style_css(this.$el, 'minHeight', this.minHeight);\n            }\n\n            // IE 11 fix (min-height on a flex container won't apply to its flex items)\n            if (viewport - offsetTop >= elHeight) {\n                style_css(this.$el, 'height', minHeight);\n            }\n\n        },\n\n        events: ['load', 'resize']\n\n    }\n\n});\n\nfunction offsetHeight(el) {\n    return el && el.offsetHeight || 0;\n}\n\n// CONCATENATED MODULE: ./src/js/core/svg.js\n\n\nconst svgs = {};\n\n/* harmony default export */ var core_svg = ({\n\n    attrs: true,\n\n    props: {\n        id: String,\n        icon: String,\n        src: String,\n        style: String,\n        width: Number,\n        height: Number,\n        ratio: Number,\n        'class': String\n    },\n\n    data: {\n        ratio: 1,\n        id: false,\n        exclude: ['ratio', 'src', 'icon'],\n        'class': ''\n    },\n\n    connected() {\n\n        this.class += ' uk-svg';\n\n        if (!this.icon && Object(lang[\"includes\"])(this.src, '#')) {\n\n            const parts = this.src.split('#');\n\n            if (parts.length > 1) {\n                [this.src, this.icon] = parts;\n            }\n        }\n\n        this.svg = this.getSvg().then(svg => {\n\n            let el;\n\n            if (Object(lang[\"isString\"])(svg)) {\n\n                if (this.icon && Object(lang[\"includes\"])(svg, '<symbol')) {\n                    svg = parseSymbols(svg, this.icon) || svg;\n                }\n\n                el = $(svg.substr(svg.indexOf('<svg')));\n\n            } else {\n                el = svg.cloneNode(true);\n            }\n\n            if (!el) {\n                return util_promise[\"Promise\"].reject('SVG not found.');\n            }\n\n            let dimensions = attr_attr(el, 'viewBox');\n\n            if (dimensions) {\n                dimensions = dimensions.split(' ');\n                this.width = this.$props.width || dimensions[2];\n                this.height = this.$props.height || dimensions[3];\n            }\n\n            this.width *= this.ratio;\n            this.height *= this.ratio;\n\n            for (const prop in this.$options.props) {\n                if (this[prop] && !Object(lang[\"includes\"])(this.exclude, prop)) {\n                    attr_attr(el, prop, this[prop]);\n                }\n            }\n\n            if (!this.id) {\n                removeAttr(el, 'id');\n            }\n\n            if (this.width && !this.height) {\n                removeAttr(el, 'height');\n            }\n\n            if (this.height && !this.width) {\n                removeAttr(el, 'width');\n            }\n\n            const root = this.$el;\n            if (isVoidElement(root) || root.tagName === 'CANVAS') {\n\n                attr_attr(root, {hidden: true, id: null});\n\n                const next = root.nextElementSibling;\n                if (next && el.isEqualNode(next)) {\n                    el = next;\n                } else {\n                    after(root, el);\n                }\n\n            } else {\n\n                const last = root.lastElementChild;\n                if (last && el.isEqualNode(last)) {\n                    el = last;\n                } else {\n                    append(root, el);\n                }\n\n            }\n\n            this.svgEl = el;\n\n            return el;\n\n        }, lang[\"noop\"]);\n\n    },\n\n    disconnected() {\n\n        if (isVoidElement(this.$el)) {\n            attr_attr(this.$el, {hidden: null, id: this.id || null});\n        }\n\n        if (this.svg) {\n            this.svg.then(svg => (!this._connected || svg !== this.svgEl) && remove(svg), lang[\"noop\"]);\n        }\n\n        this.svg = this.svgEl = null;\n\n    },\n\n    methods: {\n\n        getSvg() {\n\n            if (!this.src) {\n                return util_promise[\"Promise\"].reject();\n            }\n\n            if (svgs[this.src]) {\n                return svgs[this.src];\n            }\n\n            svgs[this.src] = new util_promise[\"Promise\"]((resolve, reject) => {\n\n                if (Object(lang[\"startsWith\"])(this.src, 'data:')) {\n                    resolve(decodeURIComponent(this.src.split(',')[1]));\n                } else {\n\n                    ajax(this.src).then(\n                        xhr => resolve(xhr.response),\n                        () => reject('SVG not found.')\n                    );\n\n                }\n\n            });\n\n            return svgs[this.src];\n\n        }\n\n    }\n\n});\n\nconst symbolRe = /<symbol(.*?id=(['\"])(.*?)\\2[^]*?<\\/)symbol>/g;\nconst symbols = {};\n\nfunction parseSymbols(svg, icon) {\n\n    if (!symbols[svg]) {\n\n        symbols[svg] = {};\n\n        let match;\n        while ((match = symbolRe.exec(svg))) {\n            symbols[svg][match[3]] = `<svg xmlns=\"http://www.w3.org/2000/svg\"${match[1]}svg>`;\n        }\n\n        symbolRe.lastIndex = 0;\n\n    }\n\n    return symbols[svg][icon];\n}\n\n// EXTERNAL MODULE: ./src/images/components/close-icon.svg\nvar close_icon = __webpack_require__(\"./src/images/components/close-icon.svg\");\nvar close_icon_default = /*#__PURE__*/__webpack_require__.n(close_icon);\n\n// EXTERNAL MODULE: ./src/images/components/close-large.svg\nvar close_large = __webpack_require__(\"./src/images/components/close-large.svg\");\nvar close_large_default = /*#__PURE__*/__webpack_require__.n(close_large);\n\n// EXTERNAL MODULE: ./src/images/components/marker.svg\nvar marker = __webpack_require__(\"./src/images/components/marker.svg\");\nvar marker_default = /*#__PURE__*/__webpack_require__.n(marker);\n\n// EXTERNAL MODULE: ./src/images/components/navbar-toggle-icon.svg\nvar navbar_toggle_icon = __webpack_require__(\"./src/images/components/navbar-toggle-icon.svg\");\nvar navbar_toggle_icon_default = /*#__PURE__*/__webpack_require__.n(navbar_toggle_icon);\n\n// EXTERNAL MODULE: ./src/images/components/overlay-icon.svg\nvar overlay_icon = __webpack_require__(\"./src/images/components/overlay-icon.svg\");\nvar overlay_icon_default = /*#__PURE__*/__webpack_require__.n(overlay_icon);\n\n// EXTERNAL MODULE: ./src/images/components/pagination-next.svg\nvar pagination_next = __webpack_require__(\"./src/images/components/pagination-next.svg\");\nvar pagination_next_default = /*#__PURE__*/__webpack_require__.n(pagination_next);\n\n// EXTERNAL MODULE: ./src/images/components/pagination-previous.svg\nvar pagination_previous = __webpack_require__(\"./src/images/components/pagination-previous.svg\");\nvar pagination_previous_default = /*#__PURE__*/__webpack_require__.n(pagination_previous);\n\n// EXTERNAL MODULE: ./src/images/components/search-icon.svg\nvar search_icon = __webpack_require__(\"./src/images/components/search-icon.svg\");\nvar search_icon_default = /*#__PURE__*/__webpack_require__.n(search_icon);\n\n// EXTERNAL MODULE: ./src/images/components/search-large.svg\nvar search_large = __webpack_require__(\"./src/images/components/search-large.svg\");\nvar search_large_default = /*#__PURE__*/__webpack_require__.n(search_large);\n\n// EXTERNAL MODULE: ./src/images/components/search-navbar.svg\nvar search_navbar = __webpack_require__(\"./src/images/components/search-navbar.svg\");\nvar search_navbar_default = /*#__PURE__*/__webpack_require__.n(search_navbar);\n\n// EXTERNAL MODULE: ./src/images/components/slidenav-next.svg\nvar slidenav_next = __webpack_require__(\"./src/images/components/slidenav-next.svg\");\nvar slidenav_next_default = /*#__PURE__*/__webpack_require__.n(slidenav_next);\n\n// EXTERNAL MODULE: ./src/images/components/slidenav-next-large.svg\nvar slidenav_next_large = __webpack_require__(\"./src/images/components/slidenav-next-large.svg\");\nvar slidenav_next_large_default = /*#__PURE__*/__webpack_require__.n(slidenav_next_large);\n\n// EXTERNAL MODULE: ./src/images/components/slidenav-previous.svg\nvar slidenav_previous = __webpack_require__(\"./src/images/components/slidenav-previous.svg\");\nvar slidenav_previous_default = /*#__PURE__*/__webpack_require__.n(slidenav_previous);\n\n// EXTERNAL MODULE: ./src/images/components/slidenav-previous-large.svg\nvar slidenav_previous_large = __webpack_require__(\"./src/images/components/slidenav-previous-large.svg\");\nvar slidenav_previous_large_default = /*#__PURE__*/__webpack_require__.n(slidenav_previous_large);\n\n// EXTERNAL MODULE: ./src/images/components/spinner.svg\nvar spinner = __webpack_require__(\"./src/images/components/spinner.svg\");\nvar spinner_default = /*#__PURE__*/__webpack_require__.n(spinner);\n\n// EXTERNAL MODULE: ./src/images/components/totop.svg\nvar totop = __webpack_require__(\"./src/images/components/totop.svg\");\nvar totop_default = /*#__PURE__*/__webpack_require__.n(totop);\n\n// CONCATENATED MODULE: ./src/js/core/icon.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst parsed = {};\nconst icons = {\n    spinner: spinner_default.a,\n    totop: totop_default.a,\n    marker: marker_default.a,\n    'close-icon': close_icon_default.a,\n    'close-large': close_large_default.a,\n    'navbar-toggle-icon': navbar_toggle_icon_default.a,\n    'overlay-icon': overlay_icon_default.a,\n    'pagination-next': pagination_next_default.a,\n    'pagination-previous': pagination_previous_default.a,\n    'search-icon': search_icon_default.a,\n    'search-large': search_large_default.a,\n    'search-navbar': search_navbar_default.a,\n    'slidenav-next': slidenav_next_default.a,\n    'slidenav-next-large': slidenav_next_large_default.a,\n    'slidenav-previous': slidenav_previous_default.a,\n    'slidenav-previous-large': slidenav_previous_large_default.a\n};\n\nconst Icon = {\n\n    install,\n\n    attrs: ['icon', 'ratio'],\n\n    mixins: [mixin_class, core_svg],\n\n    name: 'icon',\n\n    args: 'icon',\n\n    props: ['icon'],\n\n    data: {exclude: ['id', 'style', 'class', 'src', 'icon', 'ratio']},\n\n    connected() {\n        addClass(this.$el, 'uk-icon');\n    },\n\n    methods: {\n\n        getSvg() {\n\n            const icon = getIcon(applyRtl(this.icon));\n\n            if (!icon) {\n                return util_promise[\"Promise\"].reject('Icon not found.');\n            }\n\n            return util_promise[\"Promise\"].resolve(icon);\n        }\n\n    }\n\n};\n\n/* harmony default export */ var core_icon = (Icon);\n\nconst IconComponent = {\n\n    extends: Icon,\n\n    data: vm => ({\n        icon: Object(lang[\"hyphenate\"])(vm.constructor.options.name)\n    })\n\n};\n\nconst Slidenav = {\n\n    extends: IconComponent,\n\n    connected() {\n        addClass(this.$el, 'uk-slidenav');\n    },\n\n    computed: {\n\n        icon({icon}, $el) {\n            return hasClass($el, 'uk-slidenav-large')\n                ? `${icon}-large`\n                : icon;\n        }\n\n    }\n\n};\n\nconst Search = {\n\n    extends: IconComponent,\n\n    computed: {\n\n        icon({icon}, $el) {\n            return hasClass($el, 'uk-search-icon') && parents($el, '.uk-search-large').length\n                ? 'search-large'\n                : parents($el, '.uk-search-navbar').length\n                    ? 'search-navbar'\n                    : icon;\n        }\n\n    }\n\n};\n\nconst Close = {\n\n    extends: IconComponent,\n\n    connected() {\n        this.icon = `close-${hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon'}`;\n    }\n\n};\n\nconst Spinner = {\n\n    extends: IconComponent,\n\n    connected() {\n        this.svg.then(svg => this.ratio !== 1 && style_css($('circle', svg), 'strokeWidth', 1 / this.ratio), lang[\"noop\"]);\n    }\n\n};\n\nfunction install(UIkit) {\n    UIkit.icon.add = added => {\n        Object.keys(added).forEach(name => {\n            icons[name] = added[name];\n            delete parsed[name];\n        });\n\n        if (UIkit._initialized) {\n            dom_apply(document.body, el => {\n                const icon = UIkit.getComponent(el, 'icon');\n                if (icon) {\n                    icon.$reset();\n                }\n            });\n        }\n    };\n}\n\nfunction getIcon(icon) {\n\n    if (!icons[icon]) {\n        return null;\n    }\n\n    if (!parsed[icon]) {\n        parsed[icon] = $(icons[icon].trim());\n    }\n\n    return parsed[icon];\n}\n\nfunction applyRtl(icon) {\n    return isRtl ? Object(lang[\"swap\"])(Object(lang[\"swap\"])(icon, 'left', 'right'), 'previous', 'next') : icon;\n}\n\n// CONCATENATED MODULE: ./src/js/core/leader.js\n\n\n\n/* harmony default export */ var leader = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        fill: String,\n        media: 'media'\n    },\n\n    data: {\n        fill: '',\n        media: false,\n        clsWrapper: 'uk-leader-fill',\n        clsHide: 'uk-leader-hide',\n        attrFill: 'data-fill'\n    },\n\n    computed: {\n\n        fill({fill}) {\n            return fill || getCssVar('leader-fill');\n        }\n\n    },\n\n    connected() {\n        [this.wrapper] = wrapInner(this.$el, `<span class=\"${this.clsWrapper}\">`);\n    },\n\n    disconnected() {\n        unwrap(this.wrapper.childNodes);\n    },\n\n    update: [\n\n        {\n\n            read({changed, width}) {\n\n                const prev = width;\n\n                width = Math.floor(this.$el.offsetWidth / 2);\n\n                return {\n                    width,\n                    changed: changed || prev !== width,\n                    hide: this.media && !window.matchMedia(this.media).matches\n                };\n            },\n\n            write(data) {\n\n                toggleClass(this.wrapper, this.clsHide, data.hide);\n\n                if (data.changed) {\n                    data.changed = false;\n                    attr_attr(this.wrapper, this.attrFill, new Array(data.width).join(this.fill));\n                }\n\n            },\n\n            events: ['load', 'resize']\n\n        }\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/mixin/container.js\n\n\n/* harmony default export */ var mixin_container = ({\n\n    props: {\n        container: Boolean\n    },\n\n    data: {\n        container: true\n    },\n\n    computed: {\n\n        container({container}) {\n            return container === true && this.$container || container && $(container);\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/mixin/modal.js\n\n\n\n\n\nlet modal_active;\n\n/* harmony default export */ var modal = ({\n\n    mixins: [mixin_class, mixin_container, togglable],\n\n    props: {\n        selPanel: String,\n        selClose: String,\n        escClose: Boolean,\n        bgClose: Boolean,\n        stack: Boolean\n    },\n\n    data: {\n        cls: 'uk-open',\n        escClose: true,\n        bgClose: true,\n        overlay: true,\n        stack: false\n    },\n\n    computed: {\n\n        panel({selPanel}, $el) {\n            return $(selPanel, $el);\n        },\n\n        transitionElement() {\n            return this.panel;\n        },\n\n        transitionDuration() {\n            return Object(lang[\"toMs\"])(style_css(this.transitionElement, 'transitionDuration'));\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return this.selClose;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.hide();\n            }\n\n        },\n\n        {\n\n            name: 'toggle',\n\n            self: true,\n\n            handler(e) {\n\n                if (e.defaultPrevented) {\n                    return;\n                }\n\n                e.preventDefault();\n                this.toggle();\n            }\n\n        },\n\n        {\n            name: 'beforeshow',\n\n            self: true,\n\n            handler(e) {\n\n                const prev = modal_active && modal_active !== this && modal_active;\n\n                modal_active = this;\n\n                if (prev) {\n                    if (this.stack) {\n                        this.prev = prev;\n                    } else {\n                        prev.hide().then(this.show);\n                        e.preventDefault();\n                        return;\n                    }\n                }\n\n                registerEvents();\n\n            }\n\n        },\n\n        {\n            name: 'beforehide',\n\n            self: true,\n\n            handler() {\n\n                modal_active = modal_active && modal_active !== this && modal_active || this.prev;\n\n                if (!modal_active) {\n                    deregisterEvents();\n                }\n\n            }\n\n        },\n\n        {\n\n            name: 'show',\n\n            self: true,\n\n            handler() {\n\n                if (!hasClass(document.documentElement, this.clsPage)) {\n                    this.scrollbarWidth = dimensions_width(window) - dimensions_width(document);\n                    style_css(document.body, 'overflowY', this.scrollbarWidth && this.overlay ? 'scroll' : '');\n                }\n\n                addClass(document.documentElement, this.clsPage);\n\n            }\n\n        },\n\n        {\n\n            name: 'hidden',\n\n            self: true,\n\n            handler() {\n\n                let found, {prev} = this;\n\n                while (prev) {\n\n                    if (prev.clsPage === this.clsPage) {\n                        found = true;\n                        break;\n                    }\n\n                    prev = prev.prev;\n\n                }\n\n                if (!found) {\n                    removeClass(document.documentElement, this.clsPage);\n\n                }\n\n                !this.prev && style_css(document.body, 'overflowY', '');\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        toggle() {\n            return this.isToggled() ? this.hide() : this.show();\n        },\n\n        show() {\n\n            if (this.isToggled()) {\n                return util_promise[\"Promise\"].resolve();\n            }\n\n            if (this.container && this.$el.parentNode !== this.container) {\n                append(this.container, this.$el);\n                this._callConnected();\n            }\n\n            return this.toggleNow(this.$el, true);\n        },\n\n        hide() {\n            return this.isToggled()\n                ? this.toggleNow(this.$el, false)\n                : util_promise[\"Promise\"].resolve();\n        },\n\n        getActive() {\n            return modal_active;\n        },\n\n        _toggleImmediate(el, show) {\n            return new util_promise[\"Promise\"](resolve =>\n                requestAnimationFrame(() => {\n                    this._toggle(el, show);\n\n                    if (this.transitionDuration) {\n                        once(this.transitionElement, 'transitionend', resolve, false, e => e.target === this.transitionElement);\n                    } else {\n                        resolve();\n                    }\n                })\n            );\n        }\n\n    }\n\n});\n\nlet modal_events;\n\nfunction registerEvents() {\n\n    if (modal_events) {\n        return;\n    }\n\n    modal_events = [\n        on(document, 'click', ({target, defaultPrevented}) => {\n            if (modal_active && modal_active.bgClose && !defaultPrevented && (!modal_active.overlay || within(target, modal_active.$el)) && (!modal_active.panel || !within(target, modal_active.panel))) {\n                modal_active.hide();\n            }\n        }),\n        on(document, 'keydown', e => {\n            if (e.keyCode === 27 && modal_active && modal_active.escClose) {\n                e.preventDefault();\n                modal_active.hide();\n            }\n        })\n    ];\n}\n\nfunction deregisterEvents() {\n    modal_events && modal_events.forEach(unbind => unbind());\n    modal_events = null;\n}\n\n// CONCATENATED MODULE: ./src/js/core/modal.js\n\n\n\n/* harmony default export */ var core_modal = ({\n\n    install: modal_install,\n\n    mixins: [modal],\n\n    data: {\n        clsPage: 'uk-modal-page',\n        selPanel: '.uk-modal-dialog',\n        selClose: '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full'\n    },\n\n    events: [\n\n        {\n            name: 'show',\n\n            self: true,\n\n            handler() {\n\n                if (hasClass(this.panel, 'uk-margin-auto-vertical')) {\n                    addClass(this.$el, 'uk-flex');\n                } else {\n                    style_css(this.$el, 'display', 'block');\n                }\n\n                dimensions_height(this.$el); // force reflow\n            }\n        },\n\n        {\n            name: 'hidden',\n\n            self: true,\n\n            handler() {\n\n                style_css(this.$el, 'display', '');\n                removeClass(this.$el, 'uk-flex');\n\n            }\n        }\n\n    ]\n\n});\n\nfunction modal_install (UIkit) {\n\n    UIkit.modal.dialog = function (content, options) {\n\n        const dialog = UIkit.modal(`\n            <div class=\"uk-modal\">\n                <div class=\"uk-modal-dialog\">${content}</div>\n             </div>\n        `, options);\n\n        dialog.show();\n\n        on(dialog.$el, 'hidden', ({target, currentTarget}) => {\n            if (target === currentTarget) {\n                dialog.$destroy(true);\n            }\n        });\n\n        return dialog;\n    };\n\n    UIkit.modal.alert = function (message, options) {\n\n        options = Object(lang[\"assign\"])({bgClose: false, escClose: false, labels: UIkit.modal.labels}, options);\n\n        return new util_promise[\"Promise\"](\n            resolve => on(UIkit.modal.dialog(`\n                <div class=\"uk-modal-body\">${Object(lang[\"isString\"])(message) ? message : dom_html(message)}</div>\n                <div class=\"uk-modal-footer uk-text-right\">\n                    <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>${options.labels.ok}</button>\n                </div>\n            `, options).$el, 'hide', resolve)\n        );\n    };\n\n    UIkit.modal.confirm = function (message, options) {\n\n        options = Object(lang[\"assign\"])({bgClose: false, escClose: true, labels: UIkit.modal.labels}, options);\n\n        return new util_promise[\"Promise\"]((resolve, reject) => {\n\n            const confirm = UIkit.modal.dialog(`\n                <form>\n                    <div class=\"uk-modal-body\">${Object(lang[\"isString\"])(message) ? message : dom_html(message)}</div>\n                    <div class=\"uk-modal-footer uk-text-right\">\n                        <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">${options.labels.cancel}</button>\n                        <button class=\"uk-button uk-button-primary\" autofocus>${options.labels.ok}</button>\n                    </div>\n                </form>\n            `, options);\n\n            let resolved = false;\n\n            on(confirm.$el, 'submit', 'form', e => {\n                e.preventDefault();\n                resolve();\n                resolved = true;\n                confirm.hide();\n            });\n            on(confirm.$el, 'hide', () => {\n                if (!resolved) {\n                    reject();\n                }\n            });\n\n        });\n    };\n\n    UIkit.modal.prompt = function (message, value, options) {\n\n        options = Object(lang[\"assign\"])({bgClose: false, escClose: true, labels: UIkit.modal.labels}, options);\n\n        return new util_promise[\"Promise\"](resolve => {\n\n            const prompt = UIkit.modal.dialog(`\n                    <form class=\"uk-form-stacked\">\n                        <div class=\"uk-modal-body\">\n                            <label>${Object(lang[\"isString\"])(message) ? message : dom_html(message)}</label>\n                            <input class=\"uk-input\" autofocus>\n                        </div>\n                        <div class=\"uk-modal-footer uk-text-right\">\n                            <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">${options.labels.cancel}</button>\n                            <button class=\"uk-button uk-button-primary\">${options.labels.ok}</button>\n                        </div>\n                    </form>\n                `, options),\n                input = $('input', prompt.$el);\n\n            input.value = value;\n\n            let resolved = false;\n\n            on(prompt.$el, 'submit', 'form', e => {\n                e.preventDefault();\n                resolve(input.value);\n                resolved = true;\n                prompt.hide();\n            });\n            on(prompt.$el, 'hide', () => {\n                if (!resolved) {\n                    resolve(null);\n                }\n            });\n\n        });\n    };\n\n    UIkit.modal.labels = {\n        ok: 'Ok',\n        cancel: 'Cancel'\n    };\n\n}\n\n// CONCATENATED MODULE: ./src/js/core/nav.js\n\n\n/* harmony default export */ var nav = ({\n\n    extends: accordion,\n\n    data: {\n        targets: '> .uk-parent',\n        toggle: '> a',\n        content: '> ul'\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/navbar.js\n\n\n\n/* harmony default export */ var navbar = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        dropdown: String,\n        mode: 'list',\n        align: String,\n        offset: Number,\n        boundary: Boolean,\n        boundaryAlign: Boolean,\n        clsDrop: String,\n        delayShow: Number,\n        delayHide: Number,\n        dropbar: Boolean,\n        dropbarMode: String,\n        dropbarAnchor: Boolean,\n        duration: Number\n    },\n\n    data: {\n        dropdown: '.uk-navbar-nav > li',\n        align: !isRtl ? 'left' : 'right',\n        clsDrop: 'uk-navbar-dropdown',\n        mode: undefined,\n        offset: undefined,\n        delayShow: undefined,\n        delayHide: undefined,\n        boundaryAlign: undefined,\n        flip: 'x',\n        boundary: true,\n        dropbar: false,\n        dropbarMode: 'slide',\n        dropbarAnchor: false,\n        duration: 200,\n    },\n\n    computed: {\n\n        boundary({boundary, boundaryAlign}, $el) {\n            return (boundary === true || boundaryAlign) ? $el : boundary;\n        },\n\n        dropbarAnchor({dropbarAnchor}, $el) {\n            return query(dropbarAnchor, $el);\n        },\n\n        pos({align}) {\n            return `bottom-${align}`;\n        },\n\n        dropdowns({dropdown, clsDrop}, $el) {\n            return $$(`${dropdown} .${clsDrop}`, $el);\n        }\n\n    },\n\n    beforeConnect() {\n\n        const {dropbar} = this.$props;\n\n        this.dropbar = dropbar && (Object(lang[\"isString\"])(dropbar) && query(dropbar, this.$el) || $('<div></div>'));\n\n        if (this.dropbar) {\n\n            addClass(this.dropbar, 'uk-navbar-dropbar');\n\n            if (this.dropbarMode === 'slide') {\n                addClass(this.dropbar, 'uk-navbar-dropbar-slide');\n            }\n        }\n\n    },\n\n    disconnected() {\n        this.dropbar && remove(this.dropbar);\n    },\n\n    update() {\n\n        this.$create(\n            'drop',\n            this.dropdowns.filter(el => !this.getDropdown(el)),\n            Object(lang[\"assign\"])({}, this.$props, {boundary: this.boundary, pos: this.pos, offset: this.dropbar || this.offset})\n        );\n\n    },\n\n    events: [\n\n        {\n            name: 'mouseover',\n\n            delegate() {\n                return this.dropdown;\n            },\n\n            handler({current}) {\n                const active = this.getActive();\n                if (active && active.toggle && !within(active.toggle.$el, current) && !active.tracker.movesTo(active.$el)) {\n                    active.hide(false);\n                }\n            }\n\n        },\n\n        {\n            name: 'mouseleave',\n\n            el() {\n                return this.dropbar;\n            },\n\n            handler() {\n                const active = this.getActive();\n\n                if (active && !selector_matches(this.dropbar, ':hover')) {\n                    active.hide();\n                }\n            }\n        },\n\n        {\n            name: 'beforeshow',\n\n            capture: true,\n\n            filter() {\n                return this.dropbar;\n            },\n\n            handler() {\n\n                if (!this.dropbar.parentNode) {\n                    after(this.dropbarAnchor || this.$el, this.dropbar);\n                }\n\n            }\n        },\n\n        {\n            name: 'show',\n\n            capture: true,\n\n            filter() {\n                return this.dropbar;\n            },\n\n            handler(_, drop) {\n\n                const {$el, dir} = drop;\n\n                this.clsDrop && addClass($el, `${this.clsDrop}-dropbar`);\n\n                if (dir === 'bottom') {\n                    this.transitionTo($el.offsetHeight + Object(lang[\"toFloat\"])(style_css($el, 'marginTop')) + Object(lang[\"toFloat\"])(style_css($el, 'marginBottom')), $el);\n                }\n            }\n        },\n\n        {\n            name: 'beforehide',\n\n            filter() {\n                return this.dropbar;\n            },\n\n            handler(e, {$el}) {\n\n                const active = this.getActive();\n\n                if (selector_matches(this.dropbar, ':hover') && active && active.$el === $el) {\n                    e.preventDefault();\n                }\n            }\n        },\n\n        {\n            name: 'hide',\n\n            filter() {\n                return this.dropbar;\n            },\n\n            handler(_, {$el}) {\n\n                const active = this.getActive();\n\n                if (!active || active && active.$el === $el) {\n                    this.transitionTo(0);\n                }\n            }\n        }\n\n    ],\n\n    methods: {\n\n        getActive() {\n            const [active] = this.dropdowns.map(this.getDropdown).filter(drop => drop.isActive());\n            return active && Object(lang[\"includes\"])(active.mode, 'hover') && within(active.toggle.$el, this.$el) && active;\n        },\n\n        transitionTo(newHeight, el) {\n\n            const {dropbar} = this;\n            const oldHeight = isVisible(dropbar) ? dimensions_height(dropbar) : 0;\n\n            el = oldHeight < newHeight && el;\n\n            style_css(el, {height: oldHeight, overflow: 'hidden'});\n            dimensions_height(dropbar, oldHeight);\n\n            Transition.cancel([el, dropbar]);\n            return Transition\n                .start([el, dropbar], {height: newHeight}, this.duration)\n                .catch(lang[\"noop\"])\n                .then(() => style_css(el, {height: '', overflow: ''}));\n        },\n\n        getDropdown(el) {\n            return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/offcanvas.js\n\n\n\nlet offcanvas_scroll;\n\n/* harmony default export */ var offcanvas = ({\n\n    mixins: [modal],\n\n    args: 'mode',\n\n    props: {\n        content: String,\n        mode: String,\n        flip: Boolean,\n        overlay: Boolean\n    },\n\n    data: {\n        content: '.uk-offcanvas-content',\n        mode: 'slide',\n        flip: false,\n        overlay: false,\n        clsPage: 'uk-offcanvas-page',\n        clsContainer: 'uk-offcanvas-container',\n        selPanel: '.uk-offcanvas-bar',\n        clsFlip: 'uk-offcanvas-flip',\n        clsContent: 'uk-offcanvas-content',\n        clsContentAnimation: 'uk-offcanvas-content-animation',\n        clsSidebarAnimation: 'uk-offcanvas-bar-animation',\n        clsMode: 'uk-offcanvas',\n        clsOverlay: 'uk-offcanvas-overlay',\n        selClose: '.uk-offcanvas-close'\n    },\n\n    computed: {\n\n        content({content}) {\n            return $(content) || document.body;\n        },\n\n        clsFlip({flip, clsFlip}) {\n            return flip ? clsFlip : '';\n        },\n\n        clsOverlay({overlay, clsOverlay}) {\n            return overlay ? clsOverlay : '';\n        },\n\n        clsMode({mode, clsMode}) {\n            return `${clsMode}-${mode}`;\n        },\n\n        clsSidebarAnimation({mode, clsSidebarAnimation}) {\n            return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;\n        },\n\n        clsContentAnimation({mode, clsContentAnimation}) {\n            return mode !== 'push' && mode !== 'reveal' ? '' : clsContentAnimation;\n        },\n\n        transitionElement({mode}) {\n            return mode === 'reveal' ? this.panel.parentNode : this.panel;\n        }\n\n    },\n\n    update: {\n\n        write() {\n\n            if (this.getActive() === this) {\n\n                if (this.overlay || this.clsContentAnimation) {\n                    dimensions_width(this.content, dimensions_width(window) - this.scrollbarWidth);\n                }\n\n                if (this.overlay) {\n                    dimensions_height(this.content, dimensions_height(window));\n                    if (offcanvas_scroll) {\n                        this.content.scrollTop = offcanvas_scroll.y;\n                    }\n                }\n\n            }\n\n        },\n\n        events: ['resize']\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return 'a[href^=\"#\"]';\n            },\n\n            handler({current}) {\n                if (current.hash && $(current.hash, this.content)) {\n                    offcanvas_scroll = null;\n                    this.hide();\n                }\n            }\n\n        },\n\n        {\n\n            name: 'beforescroll',\n\n            filter() {\n                return this.overlay;\n            },\n\n            handler(e, scroll, target) {\n                if (scroll && target && this.isToggled() && $(target, this.content)) {\n                    once(this.$el, 'hidden', () => scroll.scrollTo(target));\n                    e.preventDefault();\n                }\n            }\n\n        },\n\n        {\n            name: 'show',\n\n            self: true,\n\n            handler() {\n\n                offcanvas_scroll = offcanvas_scroll || {x: window.scrollX, y: window.scrollY};\n\n                if (this.mode === 'reveal' && !hasClass(this.panel, this.clsMode)) {\n                    wrapAll(this.panel, '<div>');\n                    addClass(this.panel.parentNode, this.clsMode);\n                }\n\n                style_css(document.documentElement, 'overflowY', (!this.clsContentAnimation || this.flip) && this.scrollbarWidth && this.overlay ? 'scroll' : '');\n                addClass(document.body, this.clsContainer, this.clsFlip, this.clsOverlay);\n                dimensions_height(document.body); // force reflow\n                addClass(this.content, this.clsContentAnimation);\n                addClass(this.panel, this.clsSidebarAnimation, this.mode !== 'reveal' ? this.clsMode : '');\n                addClass(this.$el, this.clsOverlay);\n                style_css(this.$el, 'display', 'block');\n                dimensions_height(this.$el); // force reflow\n\n            }\n        },\n\n        {\n            name: 'hide',\n\n            self: true,\n\n            handler() {\n                removeClass(this.content, this.clsContentAnimation);\n\n                const active = this.getActive();\n                if (this.mode === 'none' || active && active !== this && active !== this.prev) {\n                    trigger(this.panel, 'transitionend');\n                }\n            }\n        },\n\n        {\n            name: 'hidden',\n\n            self: true,\n\n            handler() {\n\n                if (this.mode === 'reveal') {\n                    unwrap(this.panel);\n                }\n\n                if (!this.overlay) {\n                    offcanvas_scroll = {x: window.scrollX, y: window.scrollY};\n                } else if (!offcanvas_scroll) {\n                    const {scrollLeft: x, scrollTop: y} = this.content;\n                    offcanvas_scroll = {x, y};\n                }\n\n                removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);\n                removeClass(this.$el, this.clsOverlay);\n                style_css(this.$el, 'display', '');\n                removeClass(document.body, this.clsContainer, this.clsFlip, this.clsOverlay);\n                document.body.scrollTop = offcanvas_scroll.y;\n\n                style_css(document.documentElement, 'overflowY', '');\n\n                dimensions_width(this.content, '');\n                dimensions_height(this.content, '');\n\n                window.scroll(offcanvas_scroll.x, offcanvas_scroll.y);\n\n                offcanvas_scroll = null;\n\n            }\n        },\n\n        {\n            name: 'swipeLeft swipeRight',\n\n            handler(e) {\n\n                if (this.isToggled() && isTouch(e) && (e.type === 'swipeLeft' && !this.flip || e.type === 'swipeRight' && this.flip)) {\n                    this.hide();\n                }\n\n            }\n        }\n\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/overflow-auto.js\n\n\n\n/* harmony default export */ var overflow_auto = ({\n\n    mixins: [mixin_class],\n\n    computed: {\n\n        modal(_, $el) {\n            return closest($el, '.uk-modal');\n        },\n\n        panel(_, $el) {\n            return closest($el, '.uk-modal-dialog');\n        }\n\n    },\n\n    connected() {\n        style_css(this.$el, 'minHeight', 150);\n    },\n\n    update: {\n\n        write() {\n\n            if (!this.panel || !this.modal) {\n                return;\n            }\n\n            const current = style_css(this.$el, 'maxHeight');\n\n            style_css(style_css(this.$el, 'maxHeight', 150), 'maxHeight', Math.max(150, 150 + dimensions_height(this.modal) - this.panel.offsetHeight));\n            if (current !== style_css(this.$el, 'maxHeight')) {\n                trigger(this.$el, 'resize');\n            }\n        },\n\n        events: ['load', 'resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/responsive.js\n\n\n/* harmony default export */ var responsive = ({\n\n    props: ['width', 'height'],\n\n    connected() {\n        addClass(this.$el, 'uk-responsive-width');\n    },\n\n    update: {\n\n        read() {\n            return isVisible(this.$el) && this.width && this.height\n                ? {width: dimensions_width(this.$el.parentNode), height: this.height}\n                : false;\n        },\n\n        write(dim) {\n            dimensions_height(this.$el, lang[\"Dimensions\"].contain({height: this.height, width: this.width}, dim).height);\n        },\n\n        events: ['load', 'resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/scroll.js\n\n\n/* harmony default export */ var core_scroll = ({\n\n    props: {\n        duration: Number,\n        offset: Number\n    },\n\n    data: {\n        duration: 1000,\n        offset: 0\n    },\n\n    methods: {\n\n        scrollTo(el) {\n\n            el = el && $(el) || document.body;\n\n            const docHeight = dimensions_height(document);\n            const winHeight = dimensions_height(window);\n\n            let target = dimensions_offset(el).top - this.offset;\n            if (target + winHeight > docHeight) {\n                target = docHeight - winHeight;\n            }\n\n            if (!trigger(this.$el, 'beforescroll', [this, el])) {\n                return;\n            }\n\n            const start = Date.now();\n            const startY = window.scrollY;\n            const step = () => {\n\n                const currentY = startY + (target - startY) * ease(Object(lang[\"clamp\"])((Date.now() - start) / this.duration));\n\n                window.scroll(window.scrollX, currentY);\n\n                // scroll more if we have not reached our destination\n                if (currentY !== target) {\n                    requestAnimationFrame(step);\n                } else {\n                    trigger(this.$el, 'scrolled', [this, el]);\n                }\n\n            };\n\n            step();\n\n        }\n\n    },\n\n    events: {\n\n        click(e) {\n\n            if (e.defaultPrevented) {\n                return;\n            }\n\n            e.preventDefault();\n            this.scrollTo(selector_escape(this.$el.hash).substr(1));\n        }\n\n    }\n\n});\n\nfunction ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n}\n\n// CONCATENATED MODULE: ./src/js/core/scrollspy.js\n\n\n/* harmony default export */ var scrollspy = ({\n\n    args: 'cls',\n\n    props: {\n        cls: 'list',\n        target: String,\n        hidden: Boolean,\n        offsetTop: Number,\n        offsetLeft: Number,\n        repeat: Boolean,\n        delay: Number\n    },\n\n    data: () => ({\n        cls: [],\n        target: false,\n        hidden: true,\n        offsetTop: 0,\n        offsetLeft: 0,\n        repeat: false,\n        delay: 0,\n        inViewClass: 'uk-scrollspy-inview'\n    }),\n\n    computed: {\n\n        elements({target}, $el) {\n            return target ? $$(target, $el) : [$el];\n        }\n\n    },\n\n    update: [\n\n        {\n\n            write() {\n                if (this.hidden) {\n                    style_css(filter_filter(this.elements, `:not(.${this.inViewClass})`), 'visibility', 'hidden');\n                }\n            }\n\n        },\n\n        {\n\n            read(els) {\n\n                // Let child components be applied at least once first\n                if ((els.delay = !els.delay)) {\n                    this.$emit();\n                    return;\n                }\n\n                this.elements.forEach((el, i) => {\n\n                    let elData = els[i];\n\n                    if (!elData || elData.el !== el) {\n                        const cls = attr_data(el, 'uk-scrollspy-class');\n                        elData = {el, toggles: cls && cls.split(',') || this.cls};\n                    }\n\n                    elData.show = isInView(el, this.offsetTop, this.offsetLeft);\n                    els[i] = elData;\n\n                });\n            },\n\n            write(els) {\n\n                let index = this.elements.length === 1 ? 1 : 0;\n\n                this.elements.forEach((el, i) => {\n\n                    const elData = els[i];\n                    const cls = elData.toggles[i] || elData.toggles[0];\n\n                    if (elData.show && !elData.inview && !elData.timer) {\n\n                        const show = () => {\n                            style_css(el, 'visibility', '');\n                            addClass(el, this.inViewClass);\n                            toggleClass(el, cls);\n\n                            trigger(el, 'inview');\n\n                            this.$update(el);\n\n                            elData.inview = true;\n                            delete elData.timer;\n                        };\n\n                        if (this.delay && index) {\n                            elData.timer = setTimeout(show, this.delay * index);\n                        } else {\n                            show();\n                        }\n\n                        index++;\n\n                    } else if (!elData.show && elData.inview && this.repeat) {\n\n                        if (elData.timer) {\n                            clearTimeout(elData.timer);\n                            delete elData.timer;\n                        }\n\n                        style_css(el, 'visibility', this.hidden ? 'hidden' : '');\n                        removeClass(el, this.inViewClass);\n                        toggleClass(el, cls);\n\n                        trigger(el, 'outview');\n\n                        this.$update(el);\n\n                        elData.inview = false;\n\n                    }\n\n\n                });\n\n            },\n\n            events: ['scroll', 'load', 'resize']\n\n        }\n\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/scrollspy-nav.js\n\n\n/* harmony default export */ var scrollspy_nav = ({\n\n    props: {\n        cls: String,\n        closest: String,\n        scroll: Boolean,\n        overflow: Boolean,\n        offset: Number\n    },\n\n    data: {\n        cls: 'uk-active',\n        closest: false,\n        scroll: false,\n        overflow: true,\n        offset: 0\n    },\n\n    computed: {\n\n        links(_, $el) {\n            return $$('a[href^=\"#\"]', $el).filter(el => el.hash);\n        },\n\n        elements() {\n            return this.closest ? closest(this.links, this.closest) : this.links;\n        },\n\n        targets() {\n            return $$(this.links.map(el => el.hash).join(','));\n        }\n\n    },\n\n    update: [\n\n        {\n\n            read() {\n                if (this.scroll) {\n                    this.$create('scroll', this.links, {offset: this.offset || 0});\n                }\n            }\n\n        },\n\n        {\n\n            read(data) {\n\n                const scroll = window.scrollY + this.offset + 1;\n                const max = dimensions_height(document) - dimensions_height(window) + this.offset;\n\n                data.active = false;\n\n                this.targets.every((el, i) => {\n\n                    const {top} = dimensions_offset(el);\n                    const last = i + 1 === this.targets.length;\n\n                    if (!this.overflow && (i === 0 && top > scroll || last && top + el.offsetTop < scroll)) {\n                        return false;\n                    }\n\n                    if (!last && dimensions_offset(this.targets[i + 1]).top <= scroll) {\n                        return true;\n                    }\n\n                    if (scroll >= max) {\n                        for (let j = this.targets.length - 1; j > i; j--) {\n                            if (isInView(this.targets[j])) {\n                                el = this.targets[j];\n                                break;\n                            }\n                        }\n                    }\n\n                    return !(data.active = $(filter_filter(this.links, `[href=\"#${el.id}\"]`)));\n\n                });\n\n            },\n\n            write({active}) {\n\n                this.links.forEach(el => el.blur());\n                removeClass(this.elements, this.cls);\n\n                if (active) {\n                    trigger(this.$el, 'active', [active, addClass(this.closest ? closest(active, this.closest) : active, this.cls)]);\n                }\n\n            },\n\n            events: ['scroll', 'load', 'resize']\n\n        }\n\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/sticky.js\n\n\n\n/* harmony default export */ var sticky = ({\n\n    mixins: [mixin_class],\n\n    attrs: true,\n\n    props: {\n        top: null,\n        bottom: Boolean,\n        offset: Number,\n        animation: String,\n        clsActive: String,\n        clsInactive: String,\n        clsFixed: String,\n        clsBelow: String,\n        selTarget: String,\n        widthElement: Boolean,\n        showOnUp: Boolean,\n        media: 'media',\n        targetOffset: Number\n    },\n\n    data: {\n        top: 0,\n        bottom: false,\n        offset: 0,\n        animation: '',\n        clsActive: 'uk-active',\n        clsInactive: '',\n        clsFixed: 'uk-sticky-fixed',\n        clsBelow: 'uk-sticky-below',\n        selTarget: '',\n        widthElement: false,\n        showOnUp: false,\n        media: false,\n        targetOffset: false\n    },\n\n    computed: {\n\n        selTarget({selTarget}, $el) {\n            return selTarget && $(selTarget, $el) || $el;\n        },\n\n        widthElement({widthElement}, $el) {\n            return query(widthElement, $el) || this.placeholder;\n        }\n\n    },\n\n    connected() {\n\n        this.placeholder = $('<div class=\"uk-sticky-placeholder\"></div>');\n\n        if (!this.isActive) {\n            this.hide();\n        }\n    },\n\n    disconnected() {\n\n        if (this.isActive) {\n            this.isActive = false;\n            this.hide();\n            removeClass(this.selTarget, this.clsInactive);\n        }\n\n        remove(this.placeholder);\n        this.placeholder = null;\n        this.widthElement = null;\n    },\n\n    events: [\n\n        {\n            name: 'active',\n\n            self: true,\n\n            handler() {\n                replaceClass(this.selTarget, this.clsInactive, this.clsActive);\n            }\n\n        },\n\n        {\n            name: 'inactive',\n\n            self: true,\n\n            handler() {\n                replaceClass(this.selTarget, this.clsActive, this.clsInactive);\n            }\n\n        },\n\n        {\n\n            name: 'load hashchange popstate',\n\n            el: window,\n\n            handler() {\n\n                if (!(this.targetOffset !== false && location.hash && window.scrollY > 0)) {\n                    return;\n                }\n\n                const target = $(location.hash);\n\n                if (target) {\n                    fastdom.read(() => {\n\n                        const {top} = dimensions_offset(target);\n                        const elTop = dimensions_offset(this.$el).top;\n                        const elHeight = this.$el.offsetHeight;\n\n                        if (this.isActive && elTop + elHeight >= top && elTop <= top + target.offsetHeight) {\n                            window.scroll(0, top - elHeight - (Object(lang[\"isNumeric\"])(this.targetOffset) ? this.targetOffset : 0) - this.offset);\n                        }\n\n                    });\n                }\n\n            }\n\n        }\n\n    ],\n\n    update: [\n\n        {\n\n            write() {\n\n                const {placeholder} = this;\n                const outerHeight = (this.isActive ? placeholder : this.$el).offsetHeight;\n\n                style_css(placeholder, Object(lang[\"assign\"])(\n                    {height: style_css(this.$el, 'position') !== 'absolute' ? outerHeight : ''},\n                    style_css(this.$el, ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'])\n                ));\n\n                if (!within(placeholder, document)) {\n                    after(this.$el, placeholder);\n                    attr_attr(placeholder, 'hidden', '');\n                }\n\n                this.topOffset = dimensions_offset(this.isActive ? placeholder : this.$el).top;\n                this.bottomOffset = this.topOffset + outerHeight;\n\n                const bottom = parseProp('bottom', this);\n\n                this.top = Math.max(Object(lang[\"toFloat\"])(parseProp('top', this)), this.topOffset) - this.offset;\n                this.bottom = bottom && bottom - outerHeight;\n                this.inactive = this.media && !window.matchMedia(this.media).matches;\n\n                if (this.isActive) {\n                    this.update();\n                }\n            },\n\n            events: ['load', 'resize']\n\n        },\n\n        {\n\n            read(_, {scrollY = window.scrollY}) {\n\n                this.width = (isVisible(this.widthElement) ? this.widthElement : this.$el).offsetWidth;\n\n                return {\n                    scroll: this.scroll = scrollY,\n                    visible: isVisible(this.$el)\n                };\n            },\n\n            write({visible, scroll}, {dir} = {}) {\n\n                if (scroll < 0 || !visible || this.disabled || this.showOnUp && !dir) {\n                    return;\n                }\n\n                if (this.inactive\n                    || scroll < this.top\n                    || this.showOnUp && (scroll <= this.top || dir === 'down' || dir === 'up' && !this.isActive && scroll <= this.bottomOffset)\n                ) {\n\n                    if (!this.isActive) {\n                        return;\n                    }\n\n                    this.isActive = false;\n\n                    if (this.animation && scroll > this.topOffset) {\n                        Animation.cancel(this.$el);\n                        Animation.out(this.$el, this.animation).then(() => this.hide(), lang[\"noop\"]);\n                    } else {\n                        this.hide();\n                    }\n\n                } else if (this.isActive) {\n\n                    this.update();\n\n                } else if (this.animation) {\n\n                    Animation.cancel(this.$el);\n                    this.show();\n                    Animation.in(this.$el, this.animation).catch(lang[\"noop\"]);\n\n                } else {\n                    this.show();\n                }\n\n            },\n\n            events: ['scroll']\n\n        },\n\n    ],\n\n    methods: {\n\n        show() {\n\n            this.isActive = true;\n            this.update();\n            attr_attr(this.placeholder, 'hidden', null);\n\n        },\n\n        hide() {\n\n            if (!this.isActive || hasClass(this.selTarget, this.clsActive)) {\n                trigger(this.$el, 'inactive');\n            }\n\n            removeClass(this.$el, this.clsFixed, this.clsBelow);\n            style_css(this.$el, {position: '', top: '', width: ''});\n            attr_attr(this.placeholder, 'hidden', '');\n\n        },\n\n        update() {\n\n            const active = this.top !== 0 || this.scroll > this.top;\n            let top = Math.max(0, this.offset);\n\n            if (this.bottom && this.scroll > this.bottom - this.offset) {\n                top = this.bottom - this.scroll;\n            }\n\n            style_css(this.$el, {\n                position: 'fixed',\n                top: `${top}px`,\n                width: this.width\n            });\n\n            if (hasClass(this.selTarget, this.clsActive)) {\n\n                if (!active) {\n                    trigger(this.$el, 'inactive');\n                }\n\n            } else if (active) {\n                trigger(this.$el, 'active');\n            }\n\n            toggleClass(this.$el, this.clsBelow, this.scroll > this.bottomOffset);\n            addClass(this.$el, this.clsFixed);\n\n        }\n\n    }\n\n});\n\nfunction parseProp(prop, {$props, $el, [`${prop}Offset`]: propOffset}) {\n\n    const value = $props[prop];\n\n    if (!value) {\n        return;\n    }\n\n    if (Object(lang[\"isNumeric\"])(value)) {\n\n        return propOffset + Object(lang[\"toFloat\"])(value);\n\n    } else if (Object(lang[\"isString\"])(value) && value.match(/^-?\\d+vh$/)) {\n\n        return dimensions_height(window) * Object(lang[\"toFloat\"])(value) / 100;\n\n    } else {\n\n        const el = value === true ? $el.parentNode : query(value, $el);\n\n        if (el) {\n            return dimensions_offset(el).top + el.offsetHeight;\n        }\n\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/core/switcher.js\n\n\n\n/* harmony default export */ var switcher = ({\n\n    mixins: [togglable],\n\n    args: 'connect',\n\n    props: {\n        connect: String,\n        toggle: String,\n        active: Number,\n        swiping: Boolean\n    },\n\n    data: {\n        connect: '~.uk-switcher',\n        toggle: '> *',\n        active: 0,\n        swiping: true,\n        cls: 'uk-active',\n        clsContainer: 'uk-switcher',\n        attrItem: 'uk-switcher-item',\n        queued: true\n    },\n\n    computed: {\n\n        connects({connect}, $el) {\n            return queryAll(connect, $el);\n        },\n\n        toggles({toggle}, $el) {\n            return $$(toggle, $el);\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `${this.toggle}:not(.uk-disabled)`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(e.current);\n            }\n\n        },\n\n        {\n            name: 'click',\n\n            el() {\n                return this.connects;\n            },\n\n            delegate() {\n                return `[${this.attrItem}],[data-${this.attrItem}]`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(attr_data(e.current, this.attrItem));\n            }\n        },\n\n        {\n            name: 'swipeRight swipeLeft',\n\n            filter() {\n                return this.swiping;\n            },\n\n            el() {\n                return this.connects;\n            },\n\n            handler(e) {\n                if (!isTouch(e)) {\n                    return;\n                }\n\n                e.preventDefault();\n                if (!window.getSelection().toString()) {\n                    this.show(e.type === 'swipeLeft' ? 'next' : 'previous');\n                }\n            }\n        }\n\n    ],\n\n    update() {\n\n        this.connects.forEach(list => this.updateAria(list.children));\n        this.show(filter_filter(this.toggles, `.${this.cls}`)[0] || this.toggles[this.active] || this.toggles[0]);\n\n    },\n\n    methods: {\n\n        show(item) {\n\n            const {length} = this.toggles;\n            const prev = !!this.connects.length && dom_index(filter_filter(this.connects[0].children, `.${this.cls}`)[0]);\n            const hasPrev = prev >= 0;\n            const dir = item === 'previous' ? -1 : 1;\n\n            let toggle, next = getIndex(item, this.toggles, prev);\n\n            for (let i = 0; i < length; i++, next = (next + dir + length) % length) {\n                if (!selector_matches(this.toggles[next], '.uk-disabled, [disabled]')) {\n                    toggle = this.toggles[next];\n                    break;\n                }\n            }\n\n            if (!toggle || prev >= 0 && hasClass(toggle, this.cls) || prev === next) {\n                return;\n            }\n\n            removeClass(this.toggles, this.cls);\n            attr_attr(this.toggles, 'aria-expanded', false);\n            addClass(toggle, this.cls);\n            attr_attr(toggle, 'aria-expanded', true);\n\n            this.connects.forEach(list => {\n                if (!hasPrev) {\n                    this.toggleNow(list.children[next]);\n                } else {\n                    this.toggleElement([list.children[prev], list.children[next]]);\n                }\n            });\n\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/tab.js\n\n\n\n\n/* harmony default export */ var tab = ({\n\n    mixins: [mixin_class],\n\n    extends: switcher,\n\n    props: {\n        media: 'media'\n    },\n\n    data: {\n        media: 960,\n        attrItem: 'uk-tab-item'\n    },\n\n    connected() {\n\n        const cls = hasClass(this.$el, 'uk-tab-left')\n            ? 'uk-tab-left'\n            : hasClass(this.$el, 'uk-tab-right')\n                ? 'uk-tab-right'\n                : false;\n\n        if (cls) {\n            this.$create('toggle', this.$el, {cls, mode: 'media', media: this.media});\n        }\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/toggle.js\n\n\n\n/* harmony default export */ var core_toggle = ({\n\n    mixins: [togglable],\n\n    args: 'target',\n\n    props: {\n        href: String,\n        target: null,\n        mode: 'list',\n        media: 'media'\n    },\n\n    data: {\n        href: false,\n        target: false,\n        mode: 'click',\n        queued: true,\n        media: false\n    },\n\n    computed: {\n\n        target({href, target}, $el) {\n            target = queryAll(target || href, $el);\n            return target.length && target || [$el];\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: `${pointerEnter} ${pointerLeave}`,\n\n            filter() {\n                return Object(lang[\"includes\"])(this.mode, 'hover');\n            },\n\n            handler(e) {\n                if (!isTouch(e)) {\n                    this.toggle(`toggle${e.type === pointerEnter ? 'show' : 'hide'}`);\n                }\n            }\n\n        },\n\n        {\n\n            name: 'click',\n\n            filter() {\n                return Object(lang[\"includes\"])(this.mode, 'click') || hasTouch;\n            },\n\n            handler(e) {\n\n                if (!isTouch(e) && !Object(lang[\"includes\"])(this.mode, 'click')) {\n                    return;\n                }\n\n                // TODO better isToggled handling\n                let link;\n                if (closest(e.target, 'a[href=\"#\"], button')\n                    || (link = closest(e.target, 'a[href]')) && (\n                        this.cls\n                        || !isVisible(this.target)\n                        || link.hash && selector_matches(this.target, link.hash)\n                    )\n                ) {\n                    once(document, 'click', e => e.preventDefault());\n                }\n\n                this.toggle();\n            }\n\n        }\n    ],\n\n    update: {\n\n        write() {\n\n            if (!Object(lang[\"includes\"])(this.mode, 'media') || !this.media) {\n                return;\n            }\n\n            const toggled = this.isToggled(this.target);\n            if (window.matchMedia(this.media).matches ? !toggled : toggled) {\n                this.toggle();\n            }\n\n        },\n\n        events: ['load', 'resize']\n\n    },\n\n    methods: {\n\n        toggle(type) {\n            if (trigger(this.target, type || 'toggle', [this])) {\n                this.toggleElement(this.target);\n            }\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/core/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var js_core = (function (UIkit) {\n\n    // core components\n    UIkit.component('accordion', accordion);\n    UIkit.component('alert', core_alert);\n    UIkit.component('cover', cover);\n    UIkit.component('drop', core_drop);\n    UIkit.component('dropdown', core_dropdown);\n    UIkit.component('formCustom', form_custom);\n    UIkit.component('gif', gif);\n    UIkit.component('grid', grid);\n    UIkit.component('heightMatch', height_match);\n    UIkit.component('heightViewport', height_viewport);\n    UIkit.component('icon', core_icon);\n    UIkit.component('leader', leader);\n    UIkit.component('margin', margin);\n    UIkit.component('modal', core_modal);\n    UIkit.component('nav', nav);\n    UIkit.component('navbar', navbar);\n    UIkit.component('offcanvas', offcanvas);\n    UIkit.component('overflowAuto', overflow_auto);\n    UIkit.component('responsive', responsive);\n    UIkit.component('scroll', core_scroll);\n    UIkit.component('scrollspy', scrollspy);\n    UIkit.component('scrollspyNav', scrollspy_nav);\n    UIkit.component('sticky', sticky);\n    UIkit.component('svg', core_svg);\n    UIkit.component('switcher', switcher);\n    UIkit.component('tab', tab);\n    UIkit.component('toggle', core_toggle);\n    UIkit.component('video', core_video);\n\n    // Icon components\n    UIkit.component('close', Close);\n    UIkit.component('marker', IconComponent);\n    UIkit.component('navbarToggleIcon', IconComponent);\n    UIkit.component('overlayIcon', IconComponent);\n    UIkit.component('paginationNext', IconComponent);\n    UIkit.component('paginationPrevious', IconComponent);\n    UIkit.component('searchIcon', Search);\n    UIkit.component('slidenavNext', Slidenav);\n    UIkit.component('slidenavPrevious', Slidenav);\n    UIkit.component('spinner', Spinner);\n    UIkit.component('totop', IconComponent);\n\n    // core functionality\n    UIkit.use(core);\n\n});\n\n// CONCATENATED MODULE: ./src/js/uikit-core.js\n\n\n\n\napi.version = '3.0.0-beta.42';\n\njs_core(api);\n\nif (false) {}\n\n/* harmony default export */ var uikit_core = (api);\n\n// CONCATENATED MODULE: ./src/js/components/countdown.js\n\n\n\n/* harmony default export */ var countdown = ({\n\n    mixins: [mixin_class],\n\n    attrs: true,\n\n    props: {\n        date: String,\n        clsWrapper: String\n    },\n\n    data: {\n        date: '',\n        clsWrapper: '.uk-countdown-%unit%'\n    },\n\n    computed: {\n\n        date({date}) {\n            return Date.parse(date);\n        },\n\n        days({clsWrapper}, $el) {\n            return $(clsWrapper.replace('%unit%', 'days'), $el);\n        },\n\n        hours({clsWrapper}, $el) {\n            return $(clsWrapper.replace('%unit%', 'hours'), $el);\n        },\n\n        minutes({clsWrapper}, $el) {\n            return $(clsWrapper.replace('%unit%', 'minutes'), $el);\n        },\n\n        seconds({clsWrapper}, $el) {\n            return $(clsWrapper.replace('%unit%', 'seconds'), $el);\n        },\n\n        units() {\n            return ['days', 'hours', 'minutes', 'seconds'].filter(unit => this[unit]);\n        }\n\n    },\n\n    connected() {\n        this.start();\n    },\n\n    disconnected() {\n        this.stop();\n        this.units.forEach(unit => empty(this[unit]));\n    },\n\n    events: [\n\n        {\n\n            name: 'visibilitychange',\n\n            el: document,\n\n            handler() {\n                if (document.hidden) {\n                    this.stop();\n                } else {\n                    this.start();\n                }\n            }\n\n        }\n\n    ],\n\n    update: {\n\n        write() {\n\n            const timespan = getTimeSpan(this.date);\n\n            if (timespan.total <= 0) {\n\n                this.stop();\n\n                timespan.days\n                    = timespan.hours\n                    = timespan.minutes\n                    = timespan.seconds\n                    = 0;\n            }\n\n            this.units.forEach(unit => {\n\n                let digits = String(Math.floor(timespan[unit]));\n\n                digits = digits.length < 2 ? `0${digits}` : digits;\n\n                const el = this[unit];\n                if (el.textContent !== digits) {\n                    digits = digits.split('');\n\n                    if (digits.length !== el.children.length) {\n                        dom_html(el, digits.map(() => '<span></span>').join(''));\n                    }\n\n                    digits.forEach((digit, i) => el.children[i].textContent = digit);\n                }\n\n            });\n\n        }\n\n    },\n\n    methods: {\n\n        start() {\n\n            this.stop();\n\n            if (this.date && this.units.length) {\n                this.$emit();\n                this.timer = setInterval(() => this.$emit(), 1000);\n            }\n\n        },\n\n        stop() {\n\n            if (this.timer) {\n                clearInterval(this.timer);\n                this.timer = null;\n            }\n\n        }\n\n    }\n\n});\n\nfunction getTimeSpan(date) {\n\n    const total = date - Date.now();\n\n    return {\n        total,\n        seconds: total / 1000 % 60,\n        minutes: total / 1000 / 60 % 60,\n        hours: total / 1000 / 60 / 60 % 24,\n        days: total / 1000 / 60 / 60 / 24\n    };\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/animate.js\n\n\nconst targetClass = 'uk-animation-target';\n\n/* harmony default export */ var mixin_animate = ({\n\n    props: {\n        animation: Number\n    },\n\n    defaults: {\n        animation: 150\n    },\n\n    computed: {\n\n        target() {\n            return this.$el;\n        }\n\n    },\n\n    methods: {\n\n        animate(action) {\n\n            addStyle();\n\n            let children = Object(lang[\"toNodes\"])(this.target.children);\n            let propsFrom = children.map(el => animate_getProps(el, true));\n\n            const oldHeight = dimensions_height(this.target);\n            const oldScrollY = window.scrollY;\n\n            action();\n\n            Transition.cancel(this.target);\n            children.forEach(Transition.cancel);\n\n            animate_reset(this.target);\n            this.$update(this.target);\n\n            return new util_promise[\"Promise\"](resolve => {\n                cancelAnimationFrame(this._raf);\n                this._raf = requestAnimationFrame(() => {\n\n                    const newHeight = dimensions_height(this.target);\n\n                    children = children.concat(Object(lang[\"toNodes\"])(this.target.children).filter(el => !Object(lang[\"includes\"])(children, el)));\n\n                    const propsTo = children.map((el, i) =>\n                        el.parentNode && i in propsFrom\n                            ? propsFrom[i]\n                            ? isVisible(el)\n                                ? Object(lang[\"assign\"])({\n                                    width: el.offsetWidth,\n                                    height: el.offsetHeight,\n                                }, getPositionWithMargin(el))\n                                : {opacity: 0}\n                            : {opacity: isVisible(el) ? 1 : 0}\n                            : false\n                    );\n\n                    propsFrom = propsTo.map((props, i) => {\n                        const from = children[i].parentNode === this.target\n                            ? propsFrom[i] || animate_getProps(children[i])\n                            : false;\n\n                        if (from) {\n                            if (!props) {\n                                delete from.opacity;\n                            } else if (!('opacity' in props)) {\n                                const {opacity} = from;\n\n                                if (opacity % 1) {\n                                    props.opacity = 1;\n                                } else {\n                                    delete from.opacity;\n                                }\n                            }\n                        }\n\n                        return from;\n                    });\n\n                    addClass(this.target, targetClass);\n                    children.forEach((el, i) => propsFrom[i] && style_css(el, propsFrom[i]));\n                    style_css(this.target, 'height', oldHeight);\n                    window.scroll(window.scrollX, oldScrollY);\n\n                    util_promise[\"Promise\"].all(children.map((el, i) =>\n                        propsFrom[i] && propsTo[i]\n                            ? Transition.start(el, propsTo[i], this.animation, 'ease')\n                            : util_promise[\"Promise\"].resolve()\n                    ).concat(Transition.start(this.target, {height: newHeight}, this.animation, 'ease'))).then(() => {\n                        children.forEach((el, i) => style_css(el, {display: propsTo[i].opacity === 0 ? 'none' : '', zIndex: ''}));\n                        animate_reset(this.target);\n                        this.$update(this.target);\n                        resolve();\n                    }, lang[\"noop\"]);\n\n                });\n            });\n        }\n    }\n});\n\nfunction animate_getProps(el, opacity) {\n\n    const zIndex = style_css(el, 'zIndex');\n\n    return isVisible(el)\n        ? Object(lang[\"assign\"])({\n            display: '',\n            height: el.offsetHeight,\n            opacity: opacity ? style_css(el, 'opacity') : '0',\n            pointerEvents: 'none',\n            position: 'absolute',\n            width: el.offsetWidth,\n            zIndex: zIndex === 'auto' ? dom_index(el) : zIndex\n        }, getPositionWithMargin(el))\n        : false;\n}\n\nfunction animate_reset(el) {\n    style_css(el.children, {\n        height: '',\n        left: '',\n        opacity: '',\n        pointerEvents: '',\n        position: '',\n        top: '',\n        width: ''\n    });\n    removeClass(el, targetClass);\n    style_css(el, 'height', '');\n}\n\nfunction getPositionWithMargin(el) {\n    let {top, left} = dimensions_position(el);\n    top += Object(lang[\"toFloat\"])(style_css(el, 'marginTop'));\n    return {top, left};\n}\n\nlet animate_style;\n\nfunction addStyle() {\n    if (!animate_style) {\n        animate_style = append(document.head, '<style>').sheet;\n        animate_style.insertRule(\n            `.${targetClass} > * {\n                    margin-top: 0 !important;\n                    transform: none !important;\n                }`\n        );\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/components/filter.js\n\n\n\n/* harmony default export */ var components_filter = ({\n\n    mixins: [mixin_animate],\n\n    props: {\n        target: Boolean,\n        selActive: Boolean\n    },\n\n    data: {\n        target: null,\n        selActive: false,\n        attrItem: 'uk-filter-control',\n        cls: 'uk-active',\n        animation: 250\n    },\n\n    computed: {\n\n        toggles({attrItem}, $el) {\n            return $$(`[${this.attrItem}],[data-${this.attrItem}]`, $el);\n        },\n\n        target({target}, $el) {\n            return $(target, $el);\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `[${this.attrItem}],[data-${this.attrItem}]`;\n            },\n\n            handler(e) {\n\n                e.preventDefault();\n                this.apply(e.current);\n\n            }\n\n        }\n\n    ],\n\n    connected() {\n\n        if (this.selActive === false) {\n            return;\n        }\n\n        const actives = $$(this.selActive, this.$el);\n        this.toggles.forEach(el => toggleClass(el, this.cls, Object(lang[\"includes\"])(actives, el)));\n    },\n\n    update(data) {\n\n        const {toggles, children} = data;\n        if (isEqualList(toggles, this.toggles, false) && isEqualList(children, this.target.children, false)) {\n            return;\n        }\n\n        data.toggles = this.toggles;\n        data.children = this.target.children;\n\n        this.setState(this.getState(), false);\n\n    },\n\n    methods: {\n\n        apply(el) {\n            this.setState(mergeState(el, this.attrItem, this.getState()));\n        },\n\n        getState() {\n            return this.toggles\n                .filter(item => hasClass(item, this.cls))\n                .reduce((state, el) => mergeState(el, this.attrItem, state), {filter: {'': ''}, sort: []});\n        },\n\n        setState(state, animate = true) {\n\n            state = Object(lang[\"assign\"])({filter: {'': ''}, sort: []}, state);\n\n            trigger(this.$el, 'beforeFilter', [this, state]);\n\n            const children = Object(lang[\"toNodes\"])(this.target.children);\n\n            this.toggles.forEach(el => toggleClass(el, this.cls, matchFilter(el, this.attrItem, state)));\n\n            const apply = () => {\n\n                const selector = getSelector(state);\n\n                children.forEach(el => style_css(el, 'display', selector && !selector_matches(el, selector) ? 'none' : ''));\n\n                const [sort, order] = state.sort;\n\n                if (sort) {\n                    const sorted = sortItems(children, sort, order);\n                    if (!isEqualList(sorted, children)) {\n                        sorted.forEach(el => append(this.target, el));\n                    }\n                }\n\n            };\n\n            if (animate) {\n                this.animate(apply).then(() => trigger(this.$el, 'afterFilter', [this]));\n            } else {\n                apply();\n                trigger(this.$el, 'afterFilter', [this]);\n            }\n\n        }\n\n    }\n\n});\n\nfunction getFilter(el, attr) {\n    return parseOptions(attr_data(el, attr), ['filter']);\n}\n\nfunction mergeState(el, attr, state) {\n\n    Object(lang[\"toNodes\"])(el).forEach(el => {\n        const filterBy = getFilter(el, attr);\n        const {filter, group, sort, order = 'asc'} = filterBy;\n\n        if (filter || Object(lang[\"isUndefined\"])(sort)) {\n\n            if (group) {\n                delete state.filter[''];\n                state.filter[group] = filter;\n            } else {\n                state.filter = {'': filter};\n            }\n\n        }\n\n        if (!Object(lang[\"isUndefined\"])(sort)) {\n            state.sort = [sort, order];\n        }\n    });\n\n    return state;\n}\n\nfunction matchFilter(el, attr, {filter: stateFilter, sort: [stateSort, stateOrder]}) {\n    const {filter, group = '', sort, order = 'asc'} = getFilter(el, attr);\n    return Boolean(\n        (filter || Object(lang[\"isUndefined\"])(sort)) && group in stateFilter && (filter === stateFilter[group] || Object(lang[\"isUndefined\"])(filter) && !stateFilter[group])\n        || stateSort && sort && stateSort === sort && stateOrder === order\n    );\n}\n\nfunction isEqualList(listA, listB, strict = true) {\n\n    listA = Object(lang[\"toNodes\"])(listA);\n    listB = Object(lang[\"toNodes\"])(listB);\n\n    return listA.length === listB.length\n        && listA.every((el, i) => strict ? el === listB[i] : ~listB.indexOf(el));\n}\n\nfunction getSelector({filter}) {\n    let selector = '';\n    Object(lang[\"each\"])(filter, value => selector += value || '');\n    return selector;\n}\n\nfunction sortItems(nodes, sort, order) {\n    return Object(lang[\"toNodes\"])(nodes).sort((a, b) => attr_data(a, sort).localeCompare(attr_data(b, sort)) * (order === 'asc' || -1));\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/internal/slideshow-animations.js\n\n\n/* harmony default export */ var slideshow_animations = ({\n\n    slide: {\n\n        show(dir) {\n            return [\n                {transform: slideshow_animations_translate(dir * -100)},\n                {transform: slideshow_animations_translate()}\n            ];\n        },\n\n        percent(current) {\n            return slideshow_animations_translated(current);\n        },\n\n        translate(percent, dir) {\n            return [\n                {transform: slideshow_animations_translate(dir * -100 * percent)},\n                {transform: slideshow_animations_translate(dir * 100 * (1 - percent))}\n            ];\n        }\n\n    }\n\n});\n\nfunction slideshow_animations_translated(el) {\n    return Math.abs(style_css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;\n}\n\nfunction slideshow_animations_translate(value = 0, unit = '%') {\n    return `translateX(${value}${value ? unit : ''})`; // currently not translate3d to support IE, translate3d within translate3d does not work while transitioning\n}\n\nfunction scale3d(value) {\n    return `scale3d(${value}, ${value}, 1)`;\n}\n\n// CONCATENATED MODULE: ./src/js/components/internal/lightbox-animations.js\n\n\n\n/* harmony default export */ var lightbox_animations = (Object(lang[\"assign\"])({}, slideshow_animations, {\n\n    fade: {\n\n        show() {\n            return [\n                {opacity: 0},\n                {opacity: 1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent},\n                {opacity: percent}\n            ];\n        }\n\n    },\n\n    scale: {\n\n        show() {\n            return [\n                {opacity: 0, transform: scale3d(1 - .2)},\n                {opacity: 1, transform: scale3d(1)}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, transform: scale3d(1 - .2 * percent)},\n                {opacity: percent, transform: scale3d(1 - .2 + .2 * percent)}\n            ];\n        }\n\n    }\n\n}));\n\n// CONCATENATED MODULE: ./src/js/mixin/internal/slideshow-transitioner.js\n\n\nfunction Transitioner(prev, next, dir, {animation, easing}) {\n\n    const {percent, translate, show = lang[\"noop\"]} = animation;\n    const props = show(dir);\n    const deferred = new util_promise[\"Deferred\"]();\n\n    return {\n\n        dir,\n\n        show(duration, percent = 0, linear) {\n\n            const timing = linear ? 'linear' : easing;\n            duration -= Math.round(duration * Object(lang[\"clamp\"])(percent, -1, 1));\n\n            this.translate(percent);\n\n            triggerUpdate(next, 'itemin', {percent, duration, timing, dir});\n            triggerUpdate(prev, 'itemout', {percent: 1 - percent, duration, timing, dir});\n\n            util_promise[\"Promise\"].all([\n                Transition.start(next, props[1], duration, timing),\n                Transition.start(prev, props[0], duration, timing)\n            ]).then(() => {\n                this.reset();\n                deferred.resolve();\n            }, lang[\"noop\"]);\n\n            return deferred.promise;\n        },\n\n        stop() {\n            return Transition.stop([next, prev]);\n        },\n\n        cancel() {\n            Transition.cancel([next, prev]);\n        },\n\n        reset() {\n            for (const prop in props[0]) {\n                style_css([next, prev], prop, '');\n            }\n        },\n\n        forward(duration, percent = this.percent()) {\n            Transition.cancel([next, prev]);\n            return this.show(duration, percent, true);\n\n        },\n\n        translate(percent) {\n\n            this.reset();\n\n            const props = translate(percent, dir);\n            style_css(next, props[1]);\n            style_css(prev, props[0]);\n            triggerUpdate(next, 'itemtranslatein', {percent, dir});\n            triggerUpdate(prev, 'itemtranslateout', {percent: 1 - percent, dir});\n\n        },\n\n        percent() {\n            return percent(prev || next, next, dir);\n        },\n\n        getDistance() {\n            return prev.offsetWidth;\n        }\n\n    };\n\n}\n\nfunction triggerUpdate(el, type, data) {\n    trigger(el, createEvent(type, false, false, data));\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/slider-autoplay.js\n\n\n/* harmony default export */ var slider_autoplay = ({\n\n    props: {\n        autoplay: Boolean,\n        autoplayInterval: Number,\n        pauseOnHover: Boolean\n    },\n\n    data: {\n        autoplay: false,\n        autoplayInterval: 7000,\n        pauseOnHover: true\n    },\n\n    connected() {\n        this.startAutoplay();\n    },\n\n    disconnected() {\n        this.stopAutoplay();\n    },\n\n    events: [\n\n        {\n\n            name: 'visibilitychange',\n\n            el: document,\n\n            handler() {\n                if (document.hidden) {\n                    this.stopAutoplay();\n                } else {\n                    this.startAutoplay();\n                }\n            }\n\n        },\n\n        {\n\n            name: pointerDown,\n            handler: 'stopAutoplay'\n\n        },\n\n        {\n\n            name: 'mouseenter',\n\n            filter() {\n                return this.autoplay;\n            },\n\n            handler() {\n                this.isHovering = true;\n            }\n\n        },\n\n        {\n\n            name: 'mouseleave',\n\n            filter() {\n                return this.autoplay;\n            },\n\n            handler() {\n                this.isHovering = false;\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        startAutoplay() {\n\n            this.stopAutoplay();\n\n            if (this.autoplay) {\n                this.interval = setInterval(\n                    () => !(this.isHovering && this.pauseOnHover) && !this.stack.length && this.show('next'),\n                    this.autoplayInterval\n                );\n            }\n\n        },\n\n        stopAutoplay() {\n            if (this.interval) {\n                clearInterval(this.interval);\n            }\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/mixin/slider-drag.js\n\n\n/* harmony default export */ var slider_drag = ({\n\n    data: {\n        threshold: 10,\n        preventCatch: false\n    },\n\n    init() {\n\n        ['start', 'move', 'end'].forEach(key => {\n\n            const fn = this[key];\n            this[key] = e => {\n\n                const pos = touch_getPos(e).x * (isRtl ? -1 : 1);\n\n                this.prevPos = pos !== this.pos ? this.pos : this.prevPos;\n                this.pos = pos;\n\n                fn(e);\n            };\n\n        });\n\n    },\n\n    events: [\n\n        {\n\n            name: pointerDown,\n\n            delegate() {\n                return this.slidesSelector;\n            },\n\n            handler(e) {\n\n                if (!isTouch(e) && hasTextNodesOnly(e.target)\n                    || e.button > 0\n                    || this.length < 2\n                    || this.preventCatch\n                ) {\n                    return;\n                }\n\n                this.start(e);\n            }\n\n        },\n\n        {\n            name: 'dragstart',\n\n            handler(e) {\n                e.preventDefault();\n            }\n        }\n\n    ],\n\n    methods: {\n\n        start() {\n\n            this.drag = this.pos;\n\n            if (this._transitioner) {\n\n                this.percent = this._transitioner.percent();\n                this.drag += this._transitioner.getDistance() * this.percent * this.dir;\n\n                this._transitioner.translate(this.percent);\n                this._transitioner.cancel();\n\n                this.dragging = true;\n\n                this.stack = [];\n\n            } else {\n                this.prevIndex = this.index;\n            }\n\n            this.unbindMove = on(document, pointerMove, this.move, {capture: true, passive: false});\n            on(window, 'scroll', this.unbindMove);\n            on(document, pointerUp, this.end, true);\n\n        },\n\n        move(e) {\n\n            const distance = this.pos - this.drag;\n\n            if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {\n                return;\n            }\n\n            e.cancelable && e.preventDefault();\n\n            this.dragging = true;\n            this.dir = (distance < 0 ? 1 : -1);\n\n            const {slides} = this;\n            let {prevIndex} = this;\n            let dis = Math.abs(distance);\n            let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n            let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n            while (nextIndex !== prevIndex && dis > width) {\n\n                this.drag -= width * this.dir;\n\n                prevIndex = nextIndex;\n                dis -= width;\n                nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n                width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n            }\n\n            this.percent = dis / width;\n\n            const prev = slides[prevIndex];\n            const next = slides[nextIndex];\n            const changed = this.index !== nextIndex;\n            const edge = prevIndex === nextIndex;\n\n            let itemShown;\n\n            [this.index, this.prevIndex].filter(i => !Object(lang[\"includes\"])([nextIndex, prevIndex], i)).forEach(i => {\n                trigger(slides[i], 'itemhidden', [this]);\n\n                if (edge) {\n                    itemShown = true;\n                    this.prevIndex = prevIndex;\n                }\n\n            });\n\n            if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {\n                trigger(slides[this.index], 'itemshown', [this]);\n            }\n\n            if (changed) {\n                this.prevIndex = prevIndex;\n                this.index = nextIndex;\n\n                !edge && trigger(prev, 'beforeitemhide', [this]);\n                trigger(next, 'beforeitemshow', [this]);\n            }\n\n            this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);\n\n            if (changed) {\n                !edge && trigger(prev, 'itemhide', [this]);\n                trigger(next, 'itemshow', [this]);\n            }\n\n        },\n\n        end() {\n\n            off(window, 'scroll', this.unbindMove);\n            this.unbindMove();\n            off(document, pointerUp, this.end, true);\n\n            if (this.dragging) {\n\n                this.dragging = null;\n\n                if (this.index === this.prevIndex) {\n                    this.percent = 1 - this.percent;\n                    this.dir *= -1;\n                    this._show(false, this.index, true);\n                    this._transitioner = null;\n                } else {\n\n                    const dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;\n                    this.index = dirChange ? this.index : this.prevIndex;\n\n                    if (dirChange) {\n                        this.percent = 1 - this.percent;\n                    }\n\n                    this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);\n                }\n\n                preventClick();\n\n            }\n\n            this.drag\n                = this.percent\n                = null;\n\n        }\n\n    }\n\n});\n\nfunction hasTextNodesOnly(el) {\n    return !el.children.length && el.childNodes.length;\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/slider-nav.js\n\n\n/* harmony default export */ var slider_nav = ({\n\n    data: {\n        selNav: false\n    },\n\n    computed: {\n\n        nav({selNav}, $el) {\n            return $(selNav, $el);\n        },\n\n        navItemSelector({attrItem}) {\n            return `[${attrItem}],[data-${attrItem}]`;\n        },\n\n        navItems(_, $el) {\n            return $$(this.navItemSelector, $el);\n        }\n\n    },\n\n    update: [\n\n        {\n\n            write() {\n\n                if (this.nav && this.length !== this.nav.children.length) {\n                    dom_html(this.nav, this.slides.map((_, i) => `<li ${this.attrItem}=\"${i}\"><a href=\"#\"></a></li>`).join(''));\n                }\n\n                toggleClass($$(this.navItemSelector, this.$el).concat(this.nav), 'uk-hidden', !this.maxIndex);\n\n                this.updateNav();\n\n            },\n\n            events: ['load', 'resize']\n\n        }\n\n    ],\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return this.navItemSelector;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                e.current.blur();\n                this.show(attr_data(e.current, this.attrItem));\n            }\n\n        },\n\n        {\n\n            name: 'itemshow',\n            handler: 'updateNav'\n\n        }\n\n    ],\n\n    methods: {\n\n        updateNav() {\n\n            const i = this.getValidIndex();\n            this.navItems.forEach(el => {\n\n                const cmd = attr_data(el, this.attrItem);\n\n                toggleClass(el, this.clsActive, Object(lang[\"toNumber\"])(cmd) === i);\n                toggleClass(el, 'uk-invisible', this.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));\n            });\n\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/mixin/slider.js\n\n\n\n\n\n/* harmony default export */ var slider = ({\n\n    attrs: true,\n\n    mixins: [slider_autoplay, slider_drag, slider_nav],\n\n    props: {\n        clsActivated: Boolean,\n        easing: String,\n        index: Number,\n        finite: Boolean,\n        velocity: Number\n    },\n\n    data: () => ({\n        easing: 'ease',\n        finite: false,\n        velocity: 1,\n        index: 0,\n        stack: [],\n        percent: 0,\n        clsActive: 'uk-active',\n        clsActivated: false,\n        Transitioner: false,\n        transitionOptions: {}\n    }),\n\n    computed: {\n\n        duration({velocity}, $el) {\n            return speedUp($el.offsetWidth / velocity);\n        },\n\n        length() {\n            return this.slides.length;\n        },\n\n        list({selList}, $el) {\n            return $(selList, $el);\n        },\n\n        maxIndex() {\n            return this.length - 1;\n        },\n\n        slidesSelector({selList}) {\n            return `${selList} > *`;\n        },\n\n        slides() {\n            return Object(lang[\"toNodes\"])(this.list.children);\n        }\n\n    },\n\n    methods: {\n\n        show(index, force = false) {\n\n            if (this.dragging || !this.length) {\n                return;\n            }\n\n            const {stack} = this;\n            const queueIndex = force ? 0 : stack.length;\n            const reset = () => {\n                stack.splice(queueIndex, 1);\n\n                if (stack.length) {\n                    this.show(stack.shift(), true);\n                }\n            };\n\n            stack[force ? 'unshift' : 'push'](index);\n\n            if (!force && stack.length > 1) {\n\n                if (stack.length === 2) {\n                    this._transitioner.forward(Math.min(this.duration, 200));\n                }\n\n                return;\n            }\n\n            const prevIndex = this.index;\n            const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];\n            const nextIndex = this.getIndex(index, this.index);\n            const next = this.slides[nextIndex];\n\n            if (prev === next) {\n                reset();\n                return;\n            }\n\n            this.dir = getDirection(index, prevIndex);\n            this.prevIndex = prevIndex;\n            this.index = nextIndex;\n\n            prev && trigger(prev, 'beforeitemhide', [this]);\n            if (!trigger(next, 'beforeitemshow', [this, prev])) {\n                this.index = this.prevIndex;\n                reset();\n                return;\n            }\n\n            const promise = this._show(prev, next, force).then(() => {\n\n                prev && trigger(prev, 'itemhidden', [this]);\n                trigger(next, 'itemshown', [this]);\n\n                return new util_promise[\"Promise\"](resolve => {\n                    fastdom.write(() => {\n                        stack.shift();\n                        if (stack.length) {\n                            this.show(stack.shift(), true);\n                        } else {\n                            this._transitioner = null;\n                        }\n                        resolve();\n                    });\n                });\n\n            });\n\n            prev && trigger(prev, 'itemhide', [this]);\n            trigger(next, 'itemshow', [this]);\n\n            return promise;\n\n        },\n\n        getIndex(index = this.index, prev = this.index) {\n            return Object(lang[\"clamp\"])(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n            return this.getIndex(index, prevIndex);\n        },\n\n        _show(prev, next, force) {\n\n            this._transitioner = this._getTransitioner(\n                prev,\n                next,\n                this.dir,\n                Object(lang[\"assign\"])({\n                    easing: force\n                        ? next.offsetWidth < 600\n                            ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */\n                            : 'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */\n                        : this.easing\n                }, this.transitionOptions)\n            );\n\n            if (!force && !prev) {\n                this._transitioner.translate(1);\n                return util_promise[\"Promise\"].resolve();\n            }\n\n            const {length} = this.stack;\n            return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);\n\n        },\n\n        _getDistance(prev, next) {\n            return new this._getTransitioner(prev, prev !== next && next).getDistance();\n        },\n\n        _translate(percent, prev = this.prevIndex, next = this.index) {\n            const transitioner = this._getTransitioner(prev !== next ? prev : false, next);\n            transitioner.translate(percent);\n            return transitioner;\n        },\n\n        _getTransitioner(prev = this.prevIndex, next = this.index, dir = this.dir || 1, options = this.transitionOptions) {\n            return new this.Transitioner(\n                Object(lang[\"isNumber\"])(prev) ? this.slides[prev] : prev,\n                Object(lang[\"isNumber\"])(next) ? this.slides[next] : next,\n                dir * (isRtl ? -1 : 1),\n                options\n            );\n        }\n\n    }\n\n});\n\nfunction getDirection(index, prevIndex) {\n    return index === 'next'\n        ? 1\n        : index === 'previous'\n            ? -1\n            : index < prevIndex\n                ? -1\n                : 1;\n}\n\nfunction speedUp(x) {\n    return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/slideshow.js\n\n\n\n\n\n/* harmony default export */ var slideshow = ({\n\n    mixins: [slider],\n\n    props: {\n        animation: String\n    },\n\n    data: {\n        animation: 'slide',\n        clsActivated: 'uk-transition-active',\n        Animations: slideshow_animations,\n        Transitioner: Transitioner\n    },\n\n    computed: {\n\n        animation({animation, Animations}) {\n            return Object(lang[\"assign\"])(animation in Animations ? Animations[animation] : Animations.slide, {name: animation});\n        },\n\n        transitionOptions() {\n            return {animation: this.animation};\n        }\n\n    },\n\n    events: {\n\n        'itemshow itemhide itemshown itemhidden'({target}) {\n            this.$update(target);\n        },\n\n        itemshow() {\n            Object(lang[\"isNumber\"])(this.prevIndex) && fastdom.flush(); // iOS 10+ will honor the video.play only if called from a gesture handler\n        },\n\n        beforeitemshow({target}) {\n            addClass(target, this.clsActive);\n        },\n\n        itemshown({target}) {\n            addClass(target, this.clsActivated);\n        },\n\n        itemhidden({target}) {\n            removeClass(target, this.clsActive, this.clsActivated);\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/components/lightbox-panel.js\n\n\n\n\n\n\n\n/* harmony default export */ var lightbox_panel = ({\n\n    mixins: [mixin_container, modal, togglable, slideshow],\n\n    functional: true,\n\n    props: {\n        delayControls: Number,\n        preload: Number,\n        videoAutoplay: Boolean,\n        template: String\n    },\n\n    data: () => ({\n        preload: 1,\n        videoAutoplay: false,\n        delayControls: 3000,\n        items: [],\n        cls: 'uk-open',\n        clsPage: 'uk-lightbox-page',\n        selList: '.uk-lightbox-items',\n        attrItem: 'uk-lightbox-item',\n        selClose: '.uk-close-large',\n        pauseOnHover: false,\n        velocity: 2,\n        Animations: lightbox_animations,\n        template: `<div class=\"uk-lightbox uk-overflow-hidden\">\n                            <ul class=\"uk-lightbox-items\"></ul>\n                            <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\">\n                                <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button>\n                             </div>\n                            <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href=\"#\" uk-slidenav-previous uk-lightbox-item=\"previous\"></a>\n                            <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href=\"#\" uk-slidenav-next uk-lightbox-item=\"next\"></a>\n                            <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div>\n                        </div>`\n    }),\n\n    created() {\n\n        this.$mount(append(this.container, this.template));\n\n        this.caption = $('.uk-lightbox-caption', this.$el);\n\n        this.items.forEach(() => append(this.list, '<li></li>'));\n\n    },\n\n    events: [\n\n        {\n\n            name: `${pointerMove} ${pointerDown} keydown`,\n\n            handler: 'showControls'\n\n        },\n\n        {\n\n            name: 'click',\n\n            self: true,\n\n            delegate() {\n                return this.slidesSelector;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.hide();\n            }\n\n        },\n\n        {\n\n            name: 'shown',\n\n            self: true,\n\n            handler: 'showControls'\n        },\n\n        {\n\n            name: 'hide',\n\n            self: true,\n\n            handler() {\n\n                this.hideControls();\n\n                removeClass(this.slides, this.clsActive);\n                Transition.stop(this.slides);\n\n            }\n        },\n\n        {\n\n            name: 'keyup',\n\n            el: document,\n\n            handler(e) {\n\n                if (!this.isToggled(this.$el)) {\n                    return;\n                }\n\n                switch (e.keyCode) {\n                    case 37:\n                        this.show('previous');\n                        break;\n                    case 39:\n                        this.show('next');\n                        break;\n                }\n            }\n        },\n\n        {\n\n            name: 'beforeitemshow',\n\n            handler(e) {\n\n                if (this.isToggled()) {\n                    return;\n                }\n\n                this.preventCatch = true;\n\n                e.preventDefault();\n\n                this.toggleNow(this.$el, true);\n\n                this.animation = lightbox_animations['scale'];\n                removeClass(e.target, this.clsActive);\n                this.stack.splice(1, 0, this.index);\n\n            }\n\n        },\n\n        {\n\n            name: 'itemshow',\n\n            handler({target}) {\n\n                const i = dom_index(target);\n                const {caption} = this.getItem(i);\n\n                style_css(this.caption, 'display', caption ? '' : 'none');\n                dom_html(this.caption, caption);\n\n                for (let j = 0; j <= this.preload; j++) {\n                    this.loadItem(this.getIndex(i + j));\n                    this.loadItem(this.getIndex(i - j));\n                }\n\n            }\n\n        },\n\n        {\n\n            name: 'itemshown',\n\n            handler() {\n                this.preventCatch = false;\n            }\n\n        },\n\n        {\n\n            name: 'itemload',\n\n            handler(_, item) {\n\n                const {source, type, alt} = item;\n\n                this.setItem(item, '<span uk-spinner></span>');\n\n                if (!source) {\n                    return;\n                }\n\n                let matches;\n\n                // Image\n                if (type === 'image' || source.match(/\\.(jp(e)?g|png|gif|svg)$/i)) {\n\n                    getImage(source).then(\n                        img => this.setItem(item, `<img width=\"${img.width}\" height=\"${img.height}\" src=\"${source}\" alt=\"${alt ? alt : ''}\">`),\n                        () => this.setError(item)\n                    );\n\n                    // Video\n                } else if (type === 'video' || source.match(/\\.(mp4|webm|ogv)$/i)) {\n\n                    const video = $(`<video controls playsinline${item.poster ? ` poster=\"${item.poster}\"` : ''} uk-video=\"${this.videoAutoplay}\"></video>`);\n                    attr_attr(video, 'src', source);\n\n                    on(video, 'error', () => this.setError(item));\n                    on(video, 'loadedmetadata', () => {\n                        attr_attr(video, {width: video.videoWidth, height: video.videoHeight});\n                        this.setItem(item, video);\n                    });\n\n                    // Iframe\n                } else if (type === 'iframe') {\n\n                    this.setItem(item, `<iframe class=\"uk-lightbox-iframe\" src=\"${source}\" frameborder=\"0\" allowfullscreen></iframe>`);\n\n                    // YouTube\n                } else if ((matches = source.match(/\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/watch\\?v=([^&\\s]+)/) || source.match(/()youtu\\.be\\/(.*)/))) {\n\n                    const [, , id] = matches;\n                    const setIframe = (width = 640, height = 450) => this.setItem(item, getIframe(`//www.youtube${matches[1] || ''}.com/embed/${id}`, width, height, this.videoAutoplay));\n\n                    getImage(`//img.youtube.com/vi/${id}/maxresdefault.jpg`).then(\n                        ({width, height}) => {\n                            // YouTube default 404 thumb, fall back to low resolution\n                            if (width === 120 && height === 90) {\n                                getImage(`//img.youtube.com/vi/${id}/0.jpg`).then(\n                                    ({width, height}) => setIframe(width, height),\n                                    setIframe\n                                );\n                            } else {\n                                setIframe(width, height);\n                            }\n                        },\n                        setIframe\n                    );\n\n                    // Vimeo\n                } else if ((matches = source.match(/(\\/\\/.*?)vimeo\\.[a-z]+\\/([0-9]+).*?/))) {\n\n                    ajax(`//vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI(source)}`, {responseType: 'json'})\n                        .then(({response: {height, width}}) =>\n                            this.setItem(item, getIframe(`//player.vimeo.com/video/${matches[2]}`, width, height, this.videoAutoplay))\n                        );\n\n                }\n\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        loadItem(index = this.index) {\n\n            const item = this.getItem(index);\n\n            if (item.content) {\n                return;\n            }\n\n            trigger(this.$el, 'itemload', [item]);\n        },\n\n        getItem(index = this.index) {\n            return this.items[index] || {};\n        },\n\n        setItem(item, content) {\n            Object(lang[\"assign\"])(item, {content});\n            const el = dom_html(this.slides[this.items.indexOf(item)], content);\n            trigger(this.$el, 'itemloaded', [this, el]);\n            this.$update(el);\n        },\n\n        setError(item) {\n            this.setItem(item, '<span uk-icon=\"icon: bolt; ratio: 2\"></span>');\n        },\n\n        showControls() {\n\n            clearTimeout(this.controlsTimer);\n            this.controlsTimer = setTimeout(this.hideControls, this.delayControls);\n\n            addClass(this.$el, 'uk-active', 'uk-transition-active');\n\n        },\n\n        hideControls() {\n            removeClass(this.$el, 'uk-active', 'uk-transition-active');\n        }\n\n    }\n\n});\n\nfunction getIframe(src, width, height, autoplay) {\n    return `<iframe src=\"${src}\" width=\"${width}\" height=\"${height}\" style=\"max-width: 100%; box-sizing: border-box;\" frameborder=\"0\" allowfullscreen uk-video=\"autoplay: ${autoplay}\" uk-responsive></iframe>`;\n}\n\n// CONCATENATED MODULE: ./src/js/components/lightbox.js\n\n\n\n/* harmony default export */ var lightbox = ({\n\n    attrs: true,\n\n    props: Object(lang[\"assign\"])({toggle: String}, lightbox_panel.props),\n\n    data: Object(lang[\"assign\"])({toggle: 'a'}, Object.keys(lightbox_panel.props).reduce((data, key) => {\n        data[key] = lightbox_panel.data[key];\n        return data;\n    }, {})),\n\n    computed: {\n\n        toggles({toggle}, $el) {\n            return $$(toggle, $el);\n        }\n\n    },\n\n    disconnected() {\n        this._destroy();\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `${this.toggle}:not(.uk-disabled)`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                e.current.blur();\n                this.show(dom_index(this.toggles, e.current));\n            }\n\n        }\n\n    ],\n\n    update(data) {\n\n        data.toggles = data.toggles || this.toggles;\n\n        if (this.panel && this.animation) {\n            this.panel.$props.animation = this.animation;\n            this.panel.$emit();\n        }\n\n        if (!this.panel || lightbox_isEqualList(data.toggles, this.toggles)) {\n            return;\n        }\n\n        data.toggles = this.toggles;\n        this._destroy();\n        this._init();\n\n    },\n\n    methods: {\n\n        _init() {\n            return this.panel = this.panel || this.$create('lightboxPanel', Object(lang[\"assign\"])({}, this.$props, {\n                items: this.toggles.reduce((items, el) => {\n                    items.push(['href', 'caption', 'type', 'poster', 'alt'].reduce((obj, attr) => {\n                        obj[attr === 'href' ? 'source' : attr] = attr_data(el, attr);\n                        return obj;\n                    }, {}));\n                    return items;\n                }, [])\n            }));\n        },\n\n        _destroy() {\n            if (this.panel) {\n                this.panel.$destroy(true);\n                this.panel = null;\n            }\n        },\n\n        show(index) {\n\n            if (!this.panel) {\n                this._init();\n            }\n\n            return this.panel.show(index);\n\n        },\n\n        hide() {\n\n            return this.panel && this.panel.hide();\n\n        }\n\n    }\n\n});\n\nfunction lightbox_isEqualList(listA, listB) {\n    return listA.length === listB.length\n        && listA.every((el, i) => el === listB[i]);\n}\n\n// CONCATENATED MODULE: ./src/js/components/notification.js\n\n\nconst containers = {};\n\n/* harmony default export */ var notification = ({\n\n    functional: true,\n\n    args: ['message', 'status'],\n\n    data: {\n        message: '',\n        status: '',\n        timeout: 5000,\n        group: null,\n        pos: 'top-center',\n        clsClose: 'uk-notification-close',\n        clsMsg: 'uk-notification-message'\n    },\n\n    install: notification_install,\n\n    created() {\n\n        if (!containers[this.pos]) {\n            containers[this.pos] = append(this.$container, `<div class=\"uk-notification uk-notification-${this.pos}\"></div>`);\n        }\n\n        const container = style_css(containers[this.pos], 'display', 'block');\n\n        this.$mount(append(container,\n            `<div class=\"${this.clsMsg}${this.status ? ` ${this.clsMsg}-${this.status}` : ''}\">\n                    <a href=\"#\" class=\"${this.clsClose}\" data-uk-close></a>\n                    <div>${this.message}</div>\n                </div>`\n        ));\n\n    },\n\n    ready() {\n\n        const marginBottom = Object(lang[\"toFloat\"])(style_css(this.$el, 'marginBottom'));\n        Transition.start(\n            style_css(this.$el, {opacity: 0, marginTop: -this.$el.offsetHeight, marginBottom: 0}),\n            {opacity: 1, marginTop: 0, marginBottom}\n        ).then(() => {\n            if (this.timeout) {\n                this.timer = setTimeout(this.close, this.timeout);\n            }\n        });\n\n    },\n\n    events: {\n\n        click(e) {\n            if (closest(e.target, 'a[href=\"#\"]')) {\n                e.preventDefault();\n            }\n            this.close();\n        },\n\n        [pointerEnter]() {\n            if (this.timer) {\n                clearTimeout(this.timer);\n            }\n        },\n\n        [pointerLeave]() {\n            if (this.timeout) {\n                this.timer = setTimeout(this.close, this.timeout);\n            }\n        }\n\n    },\n\n    methods: {\n\n        close(immediate) {\n\n            const removeFn = () => {\n\n                trigger(this.$el, 'close', [this]);\n                remove(this.$el);\n\n                if (!containers[this.pos].children.length) {\n                    style_css(containers[this.pos], 'display', 'none');\n                }\n\n            };\n\n            if (this.timer) {\n                clearTimeout(this.timer);\n            }\n\n            if (immediate) {\n                removeFn();\n            } else {\n                Transition.start(this.$el, {\n                    opacity: 0,\n                    marginTop: -this.$el.offsetHeight,\n                    marginBottom: 0\n                }).then(removeFn);\n            }\n        }\n\n    }\n\n});\n\nfunction notification_install(UIkit) {\n    UIkit.notification.closeAll = function (group, immediate) {\n        dom_apply(document.body, el => {\n            const notification = UIkit.getComponent(el, 'notification');\n            if (notification && (!group || group === notification.group)) {\n                notification.close(immediate);\n            }\n        });\n    };\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/parallax.js\n\n\nconst parallax_props = ['x', 'y', 'bgx', 'bgy', 'rotate', 'scale', 'color', 'backgroundColor', 'borderColor', 'opacity', 'blur', 'hue', 'grayscale', 'invert', 'saturate', 'sepia', 'fopacity'];\n\n/* harmony default export */ var parallax = ({\n\n    props: parallax_props.reduce((props, prop) => {\n        props[prop] = 'list';\n        return props;\n    }, {\n        media: 'media'\n    }),\n\n    data: parallax_props.reduce((data, prop) => {\n        data[prop] = undefined;\n        return data;\n    }, {\n        media: false\n    }),\n\n    computed: {\n\n        props(properties, $el) {\n\n            return parallax_props.reduce((props, prop) => {\n\n                if (Object(lang[\"isUndefined\"])(properties[prop])) {\n                    return props;\n                }\n\n                const isColor = prop.match(/color/i);\n                const isCssProp = isColor || prop === 'opacity';\n\n                let pos, bgPos, diff;\n                let steps = properties[prop].slice(0);\n\n                if (isCssProp) {\n                    style_css($el, prop, '');\n                }\n\n                if (steps.length < 2) {\n                    steps.unshift((prop === 'scale'\n                        ? 1\n                        : isCssProp\n                            ? style_css($el, prop)\n                            : 0) || 0);\n                }\n\n                const unit = Object(lang[\"includes\"])(steps.join(''), '%') ? '%' : 'px';\n\n                if (isColor) {\n\n                    const {color} = $el.style;\n                    steps = steps.map(step => parseColor($el, step));\n                    $el.style.color = color;\n\n                } else {\n\n                    steps = steps.map(lang[\"toFloat\"]);\n\n                }\n\n                if (prop.match(/^bg/)) {\n\n                    style_css($el, `background-position-${prop[2]}`, '');\n                    bgPos = style_css($el, 'backgroundPosition').split(' ')[prop[2] === 'x' ? 0 : 1]; // IE 11 can't read background-position-[x|y]\n\n                    if (this.covers) {\n\n                        const min = Math.min(...steps);\n                        const max = Math.max(...steps);\n                        const down = steps.indexOf(min) < steps.indexOf(max);\n\n                        diff = max - min;\n\n                        steps = steps.map(step => step - (down ? min : max));\n                        pos = `${down ? -diff : 0}px`;\n\n                    } else {\n\n                        pos = bgPos;\n\n                    }\n                }\n\n                props[prop] = {steps, unit, pos, bgPos, diff};\n\n                return props;\n\n            }, {});\n\n        },\n\n        bgProps() {\n            return ['bgx', 'bgy'].filter(bg => bg in this.props);\n        },\n\n        covers(_, $el) {\n            return parallax_covers($el);\n        }\n\n    },\n\n    disconnected() {\n        delete this._image;\n    },\n\n    update: [\n\n        {\n\n            read(data) {\n\n                data.active = !this.media || window.matchMedia(this.media).matches;\n\n                if (data.image) {\n                    data.image.dimEl = {\n                        width: this.$el.offsetWidth,\n                        height: this.$el.offsetHeight\n                    };\n                }\n\n                if ('image' in data || !this.covers || !this.bgProps.length) {\n                    return;\n                }\n\n                const src = style_css(this.$el, 'backgroundImage').replace(/^none|url\\([\"']?(.+?)[\"']?\\)$/, '$1');\n\n                if (!src) {\n                    return;\n                }\n\n                data.image = false;\n\n                getImage(src).then(img => {\n                    data.image = {\n                        width: img.naturalWidth,\n                        height: img.naturalHeight\n                    };\n\n                    this.$emit();\n                });\n\n            },\n\n            write({image, active}) {\n\n                if (!image) {\n                    return;\n                }\n\n                if (!active) {\n                    style_css(this.$el, {backgroundSize: '', backgroundRepeat: ''});\n                    return;\n                }\n\n                const {dimEl} = image;\n\n                let dim = lang[\"Dimensions\"].cover(image, dimEl);\n\n                this.bgProps.forEach(prop => {\n\n                    const {diff, bgPos, steps} = this.props[prop];\n                    const attr = prop === 'bgy' ? 'height' : 'width';\n                    const span = dim[attr] - dimEl[attr];\n\n                    if (!bgPos.match(/%$|0px/)) {\n                        return;\n                    }\n\n                    if (span < diff) {\n                        dimEl[attr] = dim[attr] + diff - span;\n                    } else if (span > diff) {\n\n                        const bgPosFloat = parseFloat(bgPos);\n\n                        if (bgPosFloat) {\n                            this.props[prop].steps = steps.map(step => step - (span - diff) / (100 / bgPosFloat));\n                        }\n                    }\n\n                    dim = lang[\"Dimensions\"].cover(image, dimEl);\n                });\n\n                style_css(this.$el, {\n                    backgroundSize: `${dim.width}px ${dim.height}px`,\n                    backgroundRepeat: 'no-repeat'\n                });\n\n            },\n\n            events: ['load', 'resize']\n\n        }\n\n    ],\n\n    methods: {\n\n        reset() {\n            Object(lang[\"each\"])(this.getCss(0), (_, prop) => style_css(this.$el, prop, ''));\n        },\n\n        getCss(percent) {\n\n            const {props} = this;\n            let translated = false;\n\n            return Object.keys(props).reduce((css, prop) => {\n\n                const {steps, unit, pos} = props[prop];\n                const value = getValue(steps, percent);\n\n                switch (prop) {\n\n                    // transforms\n                    case 'x':\n                    case 'y':\n\n                        if (translated) {\n                            break;\n                        }\n\n                        const [x, y] = ['x', 'y'].map(dir => prop === dir\n                            ? value + unit\n                            : props[dir]\n                                ? getValue(props[dir].steps, percent) + props[dir].unit\n                                : 0\n                        );\n\n                        translated = css.transform += ` translate3d(${x}, ${y}, 0)`;\n                        break;\n                    case 'rotate':\n                        css.transform += ` rotate(${value}deg)`;\n                        break;\n                    case 'scale':\n                        css.transform += ` scale(${value})`;\n                        break;\n\n                    // bg image\n                    case 'bgy':\n                    case 'bgx':\n                        css[`background-position-${prop[2]}`] = `calc(${pos} + ${value + unit})`;\n                        break;\n\n                    // color\n                    case 'color':\n                    case 'backgroundColor':\n                    case 'borderColor':\n\n                        const [start, end, p] = getStep(steps, percent);\n\n                        css[prop] = `rgba(${\n                            start.map((value, i) => {\n                                value = value + p * (end[i] - value);\n                                return i === 3 ? Object(lang[\"toFloat\"])(value) : parseInt(value, 10);\n                            }).join(',')\n                            })`;\n                        break;\n\n                    // CSS Filter\n                    case 'blur':\n                        css.filter += ` blur(${value}px)`;\n                        break;\n                    case 'hue':\n                        css.filter += ` hue-rotate(${value}deg)`;\n                        break;\n                    case 'fopacity':\n                        css.filter += ` opacity(${value}%)`;\n                        break;\n                    case 'grayscale':\n                    case 'invert':\n                    case 'saturate':\n                    case 'sepia':\n                        css.filter += ` ${prop}(${value}%)`;\n                        break;\n\n                    default:\n                        css[prop] = value;\n                }\n\n                return css;\n\n            }, {transform: '', filter: ''});\n\n        }\n\n    }\n\n});\n\nfunction parseColor(el, color) {\n    return style_css(style_css(el, 'color', color), 'color').split(/[(),]/g).slice(1, -1).concat(1).slice(0, 4).map(n => Object(lang[\"toFloat\"])(n));\n}\n\nfunction getStep(steps, percent) {\n    const count = steps.length - 1;\n    const index = Math.min(Math.floor(count * percent), count - 1);\n    const step = steps.slice(index, index + 2);\n\n    step.push(percent === 1 ? 1 : percent % (1 / count) * count);\n\n    return step;\n}\n\nfunction getValue(steps, percent) {\n    const [start, end, p] = getStep(steps, percent);\n    return (Object(lang[\"isNumber\"])(start)\n            ? start + Math.abs(start - end) * p * (start < end ? 1 : -1)\n            : +end\n    ).toFixed(2);\n}\n\nfunction parallax_covers(el) {\n    const {backgroundSize} = el.style;\n    const covers = style_css(style_css(el, 'backgroundSize', ''), 'backgroundSize') === 'cover';\n    el.style.backgroundSize = backgroundSize;\n    return covers;\n}\n\n// CONCATENATED MODULE: ./src/js/components/parallax.js\n\n\n\n/* harmony default export */ var components_parallax = ({\n\n    mixins: [parallax],\n\n    props: {\n        target: String,\n        viewport: Number,\n        easing: Number,\n    },\n\n    data: {\n        target: false,\n        viewport: 1,\n        easing: 1,\n    },\n\n    computed: {\n\n        target({target}, $el) {\n            return target && query(target, $el) || $el;\n        }\n\n    },\n\n    update: [\n\n        {\n\n            read({percent}) {\n                return {\n                    prev: percent,\n                    percent: parallax_ease(scrolledOver(this.target) / (this.viewport || 1), this.easing)\n                };\n            },\n\n            write({prev, percent, active}, {type}) {\n\n                if (type !== 'scroll') {\n                    prev = false;\n                }\n\n                if (!active) {\n                    this.reset();\n                    return;\n                }\n\n                if (prev !== percent) {\n                    style_css(this.$el, this.getCss(percent));\n                }\n\n            },\n\n            events: ['scroll', 'load', 'resize']\n        }\n\n    ]\n\n});\n\nfunction parallax_ease(percent, easing) {\n    return Object(lang[\"clamp\"])(percent * (1 - (easing - easing * percent)));\n}\n\n// CONCATENATED MODULE: ./src/js/mixin/slider-reactive.js\n\n\n/* harmony default export */ var slider_reactive = ({\n\n    update: [\n\n        {\n\n            write() {\n\n                if (this.stack.length || this.dragging) {\n                    return;\n                }\n\n                const index = this.getValidIndex();\n                delete this.index;\n                removeClass(this.slides, this.clsActive, this.clsActivated);\n                this.show(index);\n\n            },\n\n            events: ['load', 'resize']\n\n        }\n\n    ]\n\n});\n\n// CONCATENATED MODULE: ./src/js/components/internal/slider-transitioner.js\n\n\n\n/* harmony default export */ var slider_transitioner = (function (prev, next, dir, {center, easing, list}) {\n\n    const deferred = new util_promise[\"Deferred\"]();\n\n    const from = prev\n        ? getLeft(prev, list, center)\n        : getLeft(next, list, center) + next.offsetWidth * dir;\n    const to = next\n        ? getLeft(next, list, center)\n        : from + prev.offsetWidth * dir * (isRtl ? -1 : 1);\n\n    return {\n\n        dir,\n\n        show(duration, percent = 0, linear) {\n\n            const timing = linear ? 'linear' : easing;\n            duration -= Math.round(duration * Object(lang[\"clamp\"])(percent, -1, 1));\n\n            this.translate(percent);\n\n            prev && this.updateTranslates();\n            percent = prev ? percent : Object(lang[\"clamp\"])(percent, 0, 1);\n            slider_transitioner_triggerUpdate(this.getItemIn(), 'itemin', {percent, duration, timing, dir});\n            prev && slider_transitioner_triggerUpdate(this.getItemIn(true), 'itemout', {percent: 1 - percent, duration, timing, dir});\n\n            Transition\n                .start(list, {transform: slideshow_animations_translate(-to * (isRtl ? -1 : 1), 'px')}, duration, timing)\n                .then(deferred.resolve, lang[\"noop\"]);\n\n            return deferred.promise;\n\n        },\n\n        stop() {\n            return Transition.stop(list);\n        },\n\n        cancel() {\n            Transition.cancel(list);\n        },\n\n        reset() {\n            style_css(list, 'transform', '');\n        },\n\n        forward(duration, percent = this.percent()) {\n            Transition.cancel(list);\n            return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n\n            const distance = this.getDistance() * dir * (isRtl ? -1 : 1);\n\n            style_css(list, 'transform', slideshow_animations_translate(Object(lang[\"clamp\"])(\n                -to + (distance - distance * percent),\n                -getWidth(list),\n                list.offsetWidth\n            ) * (isRtl ? -1 : 1), 'px'));\n\n            this.updateTranslates();\n\n            if (prev) {\n                percent = Object(lang[\"clamp\"])(percent, -1, 1);\n                slider_transitioner_triggerUpdate(this.getItemIn(), 'itemtranslatein', {percent, dir});\n                slider_transitioner_triggerUpdate(this.getItemIn(true), 'itemtranslateout', {percent: 1 - percent, dir});\n            }\n\n        },\n\n        percent() {\n            return Math.abs((style_css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));\n        },\n\n        getDistance() {\n            return Math.abs(to - from);\n        },\n\n        getItemIn(out = false) {\n\n            const actives = this.getActives();\n            const all = Object(lang[\"sortBy\"])(slider_transitioner_slides(list), 'offsetLeft');\n            const i = dom_index(all, actives[dir * (out ? -1 : 1) > 0 ? actives.length - 1 : 0]);\n\n            return ~i && all[i + (prev && !out ? dir : 0)];\n\n        },\n\n        getActives() {\n\n            const left = getLeft(prev || next, list, center);\n\n            return Object(lang[\"sortBy\"])(slider_transitioner_slides(list).filter(slide => {\n                const slideLeft = getElLeft(slide, list);\n                return slideLeft >= left && slideLeft + slide.offsetWidth <= list.offsetWidth + left;\n            }), 'offsetLeft');\n\n        },\n\n        updateTranslates() {\n\n            const actives = this.getActives();\n\n            slider_transitioner_slides(list).forEach(slide => {\n                const isActive = Object(lang[\"includes\"])(actives, slide);\n\n                slider_transitioner_triggerUpdate(slide, `itemtranslate${isActive ? 'in' : 'out'}`, {\n                    percent: isActive ? 1 : 0,\n                    dir: slide.offsetLeft <= next.offsetLeft ? 1 : -1\n                });\n            });\n        }\n\n    };\n\n});\n\nfunction getLeft(el, list, center) {\n\n    const left = getElLeft(el, list);\n\n    return center\n        ? left - centerEl(el, list)\n        : Math.min(left, getMax(list));\n\n}\n\nfunction getMax(list) {\n    return Math.max(0, getWidth(list) - list.offsetWidth);\n}\n\nfunction getWidth(list) {\n    return slider_transitioner_slides(list).reduce((right, el) => el.offsetWidth + right, 0);\n}\n\nfunction getMaxWidth(list) {\n    return slider_transitioner_slides(list).reduce((right, el) => Math.max(right, el.offsetWidth), 0);\n}\n\nfunction centerEl(el, list) {\n    return list.offsetWidth / 2 - el.offsetWidth / 2;\n}\n\nfunction getElLeft(el, list) {\n    return (el.offsetLeft + (isRtl ? el.offsetWidth - list.offsetWidth : 0)) * (isRtl ? -1 : 1);\n}\n\nfunction slider_transitioner_triggerUpdate(el, type, data) {\n    trigger(el, createEvent(type, false, false, data));\n}\n\nfunction slider_transitioner_slides(list) {\n    return Object(lang[\"toNodes\"])(list.children);\n}\n\n// CONCATENATED MODULE: ./src/js/components/slider.js\n\n\n\n\n\n\n/* harmony default export */ var components_slider = ({\n\n    mixins: [mixin_class, slider, slider_reactive],\n\n    props: {\n        center: Boolean,\n        sets: Boolean,\n    },\n\n    data: {\n        center: false,\n        sets: false,\n        attrItem: 'uk-slider-item',\n        selList: '.uk-slider-items',\n        selNav: '.uk-slider-nav',\n        clsContainer: 'uk-slider-container',\n        Transitioner: slider_transitioner\n    },\n\n    computed: {\n\n        avgWidth() {\n            return getWidth(this.list) / this.length;\n        },\n\n        finite({finite}) {\n            return finite || getWidth(this.list) < this.list.offsetWidth + getMaxWidth(this.list) + this.center;\n        },\n\n        maxIndex() {\n\n            if (!this.finite || this.center && !this.sets) {\n                return this.length - 1;\n            }\n\n            if (this.center) {\n                return this.sets[this.sets.length - 1];\n            }\n\n            style_css(this.slides, 'order', '');\n\n            const max = getMax(this.list);\n            let i = this.length;\n\n            while (i--) {\n                if (getElLeft(this.list.children[i], this.list) < max) {\n                    return Math.min(i + 1, this.length - 1);\n                }\n            }\n\n            return 0;\n        },\n\n        sets({sets}) {\n\n            const width = this.list.offsetWidth / (this.center ? 2 : 1);\n\n            let left = 0;\n            let leftCenter = width;\n            let slideLeft = 0;\n\n            sets = sets && this.slides.reduce((sets, slide, i) => {\n\n                const {width: slideWidth} = dimensions_offset(slide);\n                const slideRight = slideLeft + slideWidth;\n\n                if (slideRight > left) {\n\n                    if (!this.center && i > this.maxIndex) {\n                        i = this.maxIndex;\n                    }\n\n                    if (!Object(lang[\"includes\"])(sets, i)) {\n\n                        const cmp = this.slides[i + 1];\n                        if (this.center && cmp && slideWidth < leftCenter - dimensions_offset(cmp).width / 2) {\n                            leftCenter -= slideWidth;\n                        } else {\n                            leftCenter = width;\n                            sets.push(i);\n                            left = slideLeft + width + (this.center ? slideWidth / 2 : 0);\n                        }\n\n                    }\n                }\n\n                slideLeft += slideWidth;\n\n                return sets;\n\n            }, []);\n\n            return sets && sets.length && sets;\n\n        },\n\n        transitionOptions() {\n            return {\n                center: this.center,\n                list: this.list\n            };\n        }\n\n    },\n\n    connected() {\n        toggleClass(this.$el, this.clsContainer, !$(`.${this.clsContainer}`, this.$el));\n    },\n\n    update: {\n\n        write() {\n\n            $$(`[${this.attrItem}],[data-${this.attrItem}]`, this.$el).forEach(el => {\n                const index = attr_data(el, this.attrItem);\n                this.maxIndex && toggleClass(el, 'uk-hidden', Object(lang[\"isNumeric\"])(index) && (this.sets && !Object(lang[\"includes\"])(this.sets, Object(lang[\"toFloat\"])(index)) || index > this.maxIndex));\n            });\n\n        },\n\n        events: ['load', 'resize']\n\n    },\n\n    events: {\n\n        beforeitemshow(e) {\n\n            if (!this.dragging && this.sets && this.stack.length < 2 && !Object(lang[\"includes\"])(this.sets, this.index)) {\n                this.index = this.getValidIndex();\n            }\n\n            const diff = Math.abs(\n                this.index\n                - this.prevIndex\n                + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)\n            );\n\n            if (!this.dragging && diff > 1) {\n\n                for (let i = 0; i < diff; i++) {\n                    this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');\n                }\n\n                e.preventDefault();\n                return;\n            }\n\n            this.duration = speedUp(this.avgWidth / this.velocity)\n                * ((\n                    this.dir < 0 || !this.slides[this.prevIndex]\n                        ? this.slides[this.index]\n                        : this.slides[this.prevIndex]\n                ).offsetWidth / this.avgWidth);\n\n            this.reorder();\n\n        },\n\n        itemshow() {\n            !Object(lang[\"isUndefined\"])(this.prevIndex) && addClass(this._getTransitioner().getItemIn(), this.clsActive);\n        },\n\n        itemshown() {\n            const actives = this._getTransitioner(this.index).getActives();\n            this.slides.forEach(slide => toggleClass(slide, this.clsActive, Object(lang[\"includes\"])(actives, slide)));\n            (!this.sets || Object(lang[\"includes\"])(this.sets, Object(lang[\"toFloat\"])(this.index))) && this.slides.forEach(slide => toggleClass(slide, this.clsActivated, Object(lang[\"includes\"])(actives, slide)));\n        }\n\n    },\n\n    methods: {\n\n        reorder() {\n\n            style_css(this.slides, 'order', '');\n\n            if (this.finite) {\n                return;\n            }\n\n            const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;\n\n            this.slides.forEach((slide, i) =>\n                style_css(slide, 'order', this.dir > 0 && i < index\n                    ? 1\n                    : this.dir < 0 && i >= this.index\n                        ? -1\n                        : ''\n                )\n            );\n\n            if (!this.center) {\n                return;\n            }\n\n            const next = this.slides[index];\n            let width = this.list.offsetWidth / 2 - next.offsetWidth / 2;\n            let j = 0;\n\n            while (width > 0) {\n                const slideIndex = this.getIndex(--j + index, index);\n                const slide = this.slides[slideIndex];\n\n                style_css(slide, 'order', slideIndex > index ? -2 : -1);\n                width -= slide.offsetWidth;\n            }\n\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n\n            index = this.getIndex(index, prevIndex);\n\n            if (!this.sets) {\n                return index;\n            }\n\n            let prev;\n\n            do {\n\n                if (Object(lang[\"includes\"])(this.sets, index)) {\n                    return index;\n                }\n\n                prev = index;\n                index = this.getIndex(index + this.dir, prevIndex);\n\n            } while (index !== prev);\n\n            return index;\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/components/slider-parallax.js\n\n\n\n/* harmony default export */ var slider_parallax = ({\n\n    mixins: [parallax],\n\n    data: {\n        selItem: '!li'\n    },\n\n    computed: {\n\n        item({selItem}, $el) {\n            return query(selItem, $el);\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'itemshown',\n\n            self: true,\n\n            el() {\n                return this.item;\n            },\n\n            handler() {\n                style_css(this.$el, this.getCss(.5));\n            }\n\n        },\n\n        {\n            name: 'itemin itemout',\n\n            self: true,\n\n            el() {\n                return this.item;\n            },\n\n            handler({type, detail: {percent, duration, timing, dir}}) {\n\n                Transition.cancel(this.$el);\n                style_css(this.$el, this.getCss(getCurrent(type, dir, percent)));\n\n                Transition.start(this.$el, this.getCss(isIn(type)\n                    ? .5\n                    : dir > 0\n                        ? 1\n                        : 0\n                ), duration, timing).catch(lang[\"noop\"]);\n\n            }\n        },\n\n        {\n            name: 'transitioncanceled transitionend',\n\n            self: true,\n\n            el() {\n                return this.item;\n            },\n\n            handler() {\n                Transition.cancel(this.$el);\n            }\n\n        },\n\n        {\n            name: 'itemtranslatein itemtranslateout',\n\n            self: true,\n\n            el() {\n                return this.item;\n            },\n\n            handler({type, detail: {percent, dir}}) {\n                Transition.cancel(this.$el);\n                style_css(this.$el, this.getCss(getCurrent(type, dir, percent)));\n            }\n        }\n\n    ]\n\n});\n\nfunction isIn(type) {\n    return Object(lang[\"endsWith\"])(type, 'in');\n}\n\nfunction getCurrent(type, dir, percent) {\n\n    percent /= 2;\n\n    return !isIn(type)\n        ? dir < 0\n            ? percent\n            : 1 - percent\n        : dir < 0\n            ? 1 - percent\n            : percent;\n}\n\n// CONCATENATED MODULE: ./src/js/components/internal/slideshow-animations.js\n\n\n\n/* harmony default export */ var internal_slideshow_animations = (Object(lang[\"assign\"])({}, slideshow_animations, {\n\n    fade: {\n\n        show() {\n            return [\n                {opacity: 0, zIndex: 0},\n                {zIndex: -1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, zIndex: 0},\n                {zIndex: -1}\n            ];\n        }\n\n    },\n\n    scale: {\n\n        show() {\n            return [\n                {opacity: 0, transform: scale3d(1 + .5), zIndex: 0},\n                {zIndex: -1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, transform: scale3d(1 + .5 * percent), zIndex: 0},\n                {zIndex: -1}\n            ];\n        }\n\n    },\n\n    pull: {\n\n        show(dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(30), zIndex: -1},\n                    {transform: slideshow_animations_translate(), zIndex: 0},\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-100), zIndex: 0},\n                    {transform: slideshow_animations_translate(), zIndex: -1}\n                ];\n        },\n\n        percent(current, next, dir) {\n            return dir < 0\n                ? 1 - slideshow_animations_translated(next)\n                : slideshow_animations_translated(current);\n        },\n\n        translate(percent, dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(30 * percent), zIndex: -1},\n                    {transform: slideshow_animations_translate(-100 * (1 - percent)), zIndex: 0},\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-percent * 100), zIndex: 0},\n                    {transform: slideshow_animations_translate(30 * (1 - percent)), zIndex: -1}\n                ];\n        }\n\n    },\n\n    push: {\n\n        show(dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(100), zIndex: 0},\n                    {transform: slideshow_animations_translate(), zIndex: -1},\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-30), zIndex: -1},\n                    {transform: slideshow_animations_translate(), zIndex: 0}\n                ];\n        },\n\n        percent(current, next, dir) {\n            return dir > 0\n                ? 1 - slideshow_animations_translated(next)\n                : slideshow_animations_translated(current);\n        },\n\n        translate(percent, dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(percent * 100), zIndex: 0},\n                    {transform: slideshow_animations_translate(-30 * (1 - percent)), zIndex: -1},\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-30 * percent), zIndex: -1},\n                    {transform: slideshow_animations_translate(100 * (1 - percent)), zIndex: 0}\n                ];\n        }\n\n    }\n\n}));\n\n// CONCATENATED MODULE: ./src/js/components/slideshow.js\n\n\n\n\n\n\n/* harmony default export */ var components_slideshow = ({\n\n    mixins: [mixin_class, slideshow, slider_reactive],\n\n    props: {\n        ratio: String,\n        minHeight: Boolean,\n        maxHeight: Boolean,\n    },\n\n    data: {\n        ratio: '16:9',\n        minHeight: false,\n        maxHeight: false,\n        selList: '.uk-slideshow-items',\n        attrItem: 'uk-slideshow-item',\n        selNav: '.uk-slideshow-nav',\n        Animations: internal_slideshow_animations\n    },\n\n    update: {\n\n        read() {\n\n            let [width, height] = this.ratio.split(':').map(Number);\n\n            height = height * this.$el.offsetWidth / width;\n\n            if (this.minHeight) {\n                height = Math.max(this.minHeight, height);\n            }\n\n            if (this.maxHeight) {\n                height = Math.min(this.maxHeight, height);\n            }\n\n            return {height};\n        },\n\n        write({height: hgt}) {\n            dimensions_height(this.list, Math.floor(hgt));\n        },\n\n        events: ['load', 'resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/components/sortable.js\n\n\n\n\n/* harmony default export */ var components_sortable = ({\n\n    mixins: [mixin_class, mixin_animate],\n\n    props: {\n        group: String,\n        threshold: Number,\n        clsItem: String,\n        clsPlaceholder: String,\n        clsDrag: String,\n        clsDragState: String,\n        clsBase: String,\n        clsNoDrag: String,\n        clsEmpty: String,\n        clsCustom: String,\n        handle: String\n    },\n\n    data: {\n        group: false,\n        threshold: 5,\n        clsItem: 'uk-sortable-item',\n        clsPlaceholder: 'uk-sortable-placeholder',\n        clsDrag: 'uk-sortable-drag',\n        clsDragState: 'uk-drag',\n        clsBase: 'uk-sortable',\n        clsNoDrag: 'uk-sortable-nodrag',\n        clsEmpty: 'uk-sortable-empty',\n        clsCustom: '',\n        handle: false\n    },\n\n    init() {\n        ['init', 'start', 'move', 'end'].forEach(key => {\n            const fn = this[key];\n            this[key] = e => {\n                this.scrollY = window.scrollY;\n                const {x, y} = touch_getPos(e);\n                this.pos = {x, y};\n\n                fn(e);\n            };\n        });\n    },\n\n    events: {\n\n        [pointerDown]: 'init'\n\n    },\n\n    update: {\n\n        write() {\n\n            if (this.clsEmpty) {\n                toggleClass(this.$el, this.clsEmpty, !this.$el.children.length);\n            }\n\n            if (!this.drag) {\n                return;\n            }\n\n            dimensions_offset(this.drag, {top: this.pos.y + this.origin.top, left: this.pos.x + this.origin.left});\n\n            const {top} = dimensions_offset(this.drag);\n            const bottom = top + this.drag.offsetHeight;\n            let scroll;\n\n            if (top > 0 && top < this.scrollY) {\n                scroll = this.scrollY - 5;\n            } else if (bottom < dimensions_height(document) && bottom > dimensions_height(window) + this.scrollY) {\n                scroll = this.scrollY + 5;\n            }\n\n            scroll && setTimeout(() => window.scroll(window.scrollX, scroll), 5);\n        }\n\n    },\n\n    methods: {\n\n        init(e) {\n\n            const {target, button, defaultPrevented} = e;\n            const [placeholder] = Object(lang[\"toNodes\"])(this.$el.children).filter(el => within(target, el));\n\n            if (!placeholder\n                || isInput(e.target)\n                || this.handle && !within(target, this.handle)\n                || button > 0\n                || within(target, `.${this.clsNoDrag}`)\n                || defaultPrevented\n            ) {\n                return;\n            }\n\n            e.preventDefault();\n\n            this.touched = [this];\n            this.placeholder = placeholder;\n            this.origin = Object(lang[\"assign\"])({target, index: dom_index(placeholder)}, this.pos);\n\n            on(document, pointerMove, this.move);\n            on(document, pointerUp, this.end);\n            on(window, 'scroll', this.scroll);\n\n            if (!this.threshold) {\n                this.start(e);\n            }\n\n        },\n\n        start(e) {\n\n            this.drag = append(this.$container, this.placeholder.outerHTML.replace(/^<li/i, '<div').replace(/li>$/i, 'div>'));\n\n            style_css(this.drag, Object(lang[\"assign\"])({\n                boxSizing: 'border-box',\n                width: this.placeholder.offsetWidth,\n                height: this.placeholder.offsetHeight\n            }, style_css(this.placeholder, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'])));\n            attr_attr(this.drag, 'uk-no-boot', '');\n            addClass(this.drag, this.clsDrag, this.clsCustom);\n\n            dimensions_height(this.drag.firstElementChild, dimensions_height(this.placeholder.firstElementChild));\n\n            const {left, top} = dimensions_offset(this.placeholder);\n            Object(lang[\"assign\"])(this.origin, {left: left - this.pos.x, top: top - this.pos.y});\n\n            addClass(this.placeholder, this.clsPlaceholder);\n            addClass(this.$el.children, this.clsItem);\n            addClass(document.documentElement, this.clsDragState);\n\n            trigger(this.$el, 'start', [this, this.placeholder]);\n\n            this.move(e);\n        },\n\n        move(e) {\n\n            if (!this.drag) {\n\n                if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {\n                    this.start(e);\n                }\n\n                return;\n            }\n\n            this.$emit();\n\n            let target = e.type === 'mousemove' ? e.target : document.elementFromPoint(this.pos.x - document.body.scrollLeft, this.pos.y - document.body.scrollTop);\n\n            const sortable = this.getSortable(target);\n            const previous = this.getSortable(this.placeholder);\n            const move = sortable !== previous;\n\n            if (!sortable || within(target, this.placeholder) || move && (!sortable.group || sortable.group !== previous.group)) {\n                return;\n            }\n\n            target = sortable.$el === target.parentNode && target || Object(lang[\"toNodes\"])(sortable.$el.children).filter(element => within(target, element))[0];\n\n            if (move) {\n                previous.remove(this.placeholder);\n            } else if (!target) {\n                return;\n            }\n\n            sortable.insert(this.placeholder, target);\n\n            if (!Object(lang[\"includes\"])(this.touched, sortable)) {\n                this.touched.push(sortable);\n            }\n\n        },\n\n        scroll() {\n            const scroll = window.scrollY;\n            if (scroll !== this.scrollY) {\n                this.pos.y += scroll - this.scrollY;\n                this.scrollY = scroll;\n                this.$emit();\n            }\n        },\n\n        end(e) {\n\n            off(document, pointerMove, this.move);\n            off(document, pointerUp, this.end);\n            off(window, 'scroll', this.scroll);\n\n            if (!this.drag) {\n\n                if (e.type !== 'mouseup' && within(e.target, 'a[href]')) {\n                    location.href = closest(e.target, 'a[href]').href;\n                }\n\n                return;\n            }\n\n            preventClick();\n\n            const sortable = this.getSortable(this.placeholder);\n\n            if (this === sortable) {\n                if (this.origin.index !== dom_index(this.placeholder)) {\n                    trigger(this.$el, 'moved', [this, this.placeholder]);\n                }\n            } else {\n                trigger(sortable.$el, 'added', [sortable, this.placeholder]);\n                trigger(this.$el, 'removed', [this, this.placeholder]);\n            }\n\n            trigger(this.$el, 'stop', [this, this.placeholder]);\n\n            remove(this.drag);\n            this.drag = null;\n\n            const classes = this.touched.map(sortable => `${sortable.clsPlaceholder} ${sortable.clsItem}`).join(' ');\n            this.touched.forEach(sortable => removeClass(sortable.$el.children, classes));\n\n            removeClass(document.documentElement, this.clsDragState);\n\n        },\n\n        insert(element, target) {\n\n            addClass(this.$el.children, this.clsItem);\n\n            const insert = () => {\n\n                if (target) {\n\n                    if (!within(element, this.$el) || isPredecessor(element, target)) {\n                        before(target, element);\n                    } else {\n                        after(target, element);\n                    }\n\n                } else {\n                    append(this.$el, element);\n                }\n\n            };\n\n            if (this.animation) {\n                this.animate(insert);\n            } else {\n                insert();\n            }\n\n        },\n\n        remove(element) {\n\n            if (!within(element, this.$el)) {\n                return;\n            }\n\n            if (this.animation) {\n                this.animate(() => remove(element));\n            } else {\n                remove(element);\n            }\n\n        },\n\n        getSortable(element) {\n            return element && (this.$getComponent(element, 'sortable') || this.getSortable(element.parentNode));\n        }\n\n    }\n\n});\n\nfunction isPredecessor(element, target) {\n    return element.parentNode === target.parentNode && dom_index(element) > dom_index(target);\n}\n\n// CONCATENATED MODULE: ./src/js/components/tooltip.js\n\n\n\n\n\nconst tooltip_actives = [];\n\n/* harmony default export */ var tooltip = ({\n\n    attrs: true,\n\n    args: 'title',\n\n    mixins: [mixin_container, togglable, mixin_position],\n\n    props: {\n        delay: Number,\n        title: String\n    },\n\n    data: {\n        pos: 'top',\n        title: '',\n        delay: 0,\n        animation: ['uk-animation-scale-up'],\n        duration: 100,\n        cls: 'uk-active',\n        clsPos: 'uk-tooltip'\n    },\n\n    beforeConnect() {\n        this._hasTitle = hasAttr(this.$el, 'title');\n        attr_attr(this.$el, {title: '', 'aria-expanded': false});\n    },\n\n    disconnected() {\n        this.hide();\n        attr_attr(this.$el, {title: this._hasTitle ? this.title : null, 'aria-expanded': null});\n    },\n\n    methods: {\n\n        show() {\n\n            if (Object(lang[\"includes\"])(tooltip_actives, this)) {\n                return;\n            }\n\n            tooltip_actives.forEach(active => active.hide());\n            tooltip_actives.push(this);\n\n            this._unbind = on(document, 'click', e => !within(e.target, this.$el) && this.hide());\n\n            clearTimeout(this.showTimer);\n\n            this.tooltip = append(this.container, `<div class=\"${this.clsPos}\" aria-hidden><div class=\"${this.clsPos}-inner\">${this.title}</div></div>`);\n\n            attr_attr(this.$el, 'aria-expanded', true);\n\n            this.positionAt(this.tooltip, this.$el);\n\n            this.origin = this.getAxis() === 'y' ? `${flipPosition(this.dir)}-${this.align}` : `${this.align}-${flipPosition(this.dir)}`;\n\n            this.showTimer = setTimeout(() => {\n\n                this.toggleElement(this.tooltip, true);\n\n                this.hideTimer = setInterval(() => {\n\n                    if (!isVisible(this.$el)) {\n                        this.hide();\n                    }\n\n                }, 150);\n\n            }, this.delay);\n        },\n\n        hide() {\n\n            const index = tooltip_actives.indexOf(this);\n\n            if (!~index || selector_matches(this.$el, 'input') && this.$el === document.activeElement) {\n                return;\n            }\n\n            tooltip_actives.splice(index, 1);\n\n            clearTimeout(this.showTimer);\n            clearInterval(this.hideTimer);\n            attr_attr(this.$el, 'aria-expanded', false);\n            this.toggleElement(this.tooltip, false);\n            this.tooltip && remove(this.tooltip);\n            this.tooltip = false;\n            this._unbind();\n\n        }\n\n    },\n\n    events: {\n\n        [`focus ${pointerEnter} ${pointerDown}`](e) {\n            if (e.type !== pointerDown || !isTouch(e)) {\n                this.show();\n            }\n        },\n\n        blur: 'hide',\n\n        [pointerLeave](e) {\n            if (!isTouch(e)) {\n                this.hide();\n            }\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/js/components/upload.js\n\n\n/* harmony default export */ var components_upload = ({\n\n    props: {\n        allow: String,\n        clsDragover: String,\n        concurrent: Number,\n        maxSize: Number,\n        method: String,\n        mime: String,\n        msgInvalidMime: String,\n        msgInvalidName: String,\n        msgInvalidSize: String,\n        multiple: Boolean,\n        name: String,\n        params: Object,\n        type: String,\n        url: String,\n    },\n\n    data: {\n        allow: false,\n        clsDragover: 'uk-dragover',\n        concurrent: 1,\n        maxSize: 0,\n        method: 'POST',\n        mime: false,\n        msgInvalidMime: 'Invalid File Type: %s',\n        msgInvalidName: 'Invalid File Name: %s',\n        msgInvalidSize: 'Invalid File Size: %s Bytes Max',\n        multiple: false,\n        name: 'files[]',\n        params: {},\n        type: '',\n        url: '',\n        abort: lang[\"noop\"],\n        beforeAll: lang[\"noop\"],\n        beforeSend: lang[\"noop\"],\n        complete: lang[\"noop\"],\n        completeAll: lang[\"noop\"],\n        error: lang[\"noop\"],\n        fail: lang[\"noop\"],\n        load: lang[\"noop\"],\n        loadEnd: lang[\"noop\"],\n        loadStart: lang[\"noop\"],\n        progress: lang[\"noop\"]\n    },\n\n    events: {\n\n        change(e) {\n\n            if (!selector_matches(e.target, 'input[type=\"file\"]')) {\n                return;\n            }\n\n            e.preventDefault();\n\n            if (e.target.files) {\n                this.upload(e.target.files);\n            }\n\n            e.target.value = '';\n        },\n\n        drop(e) {\n            stop(e);\n\n            const transfer = e.dataTransfer;\n\n            if (!transfer || !transfer.files) {\n                return;\n            }\n\n            removeClass(this.$el, this.clsDragover);\n\n            this.upload(transfer.files);\n        },\n\n        dragenter(e) {\n            stop(e);\n        },\n\n        dragover(e) {\n            stop(e);\n            addClass(this.$el, this.clsDragover);\n        },\n\n        dragleave(e) {\n            stop(e);\n            removeClass(this.$el, this.clsDragover);\n        }\n\n    },\n\n    methods: {\n\n        upload(files) {\n\n            if (!files.length) {\n                return;\n            }\n\n            trigger(this.$el, 'upload', [files]);\n\n            for (let i = 0; i < files.length; i++) {\n\n                if (this.maxSize && this.maxSize * 1000 < files[i].size) {\n                    this.fail(this.msgInvalidSize.replace('%s', this.allow));\n                    return;\n                }\n\n                if (this.allow && !match(this.allow, files[i].name)) {\n                    this.fail(this.msgInvalidName.replace('%s', this.allow));\n                    return;\n                }\n\n                if (this.mime && !match(this.mime, files[i].type)) {\n                    this.fail(this.msgInvalidMime.replace('%s', this.mime));\n                    return;\n                }\n\n            }\n\n            if (!this.multiple) {\n                files = [files[0]];\n            }\n\n            this.beforeAll(this, files);\n\n            const chunks = chunk(files, this.concurrent);\n            const upload = files => {\n\n                const data = new FormData();\n\n                files.forEach(file => data.append(this.name, file));\n\n                for (const key in this.params) {\n                    data.append(key, this.params[key]);\n                }\n\n                ajax(this.url, {\n                    data,\n                    method: this.method,\n                    responseType: this.type,\n                    beforeSend: env => {\n\n                        const {xhr} = env;\n                        xhr.upload && on(xhr.upload, 'progress', this.progress);\n                        ['loadStart', 'load', 'loadEnd', 'abort'].forEach(type =>\n                            on(xhr, type.toLowerCase(), this[type])\n                        );\n\n                        this.beforeSend(env);\n\n                    }\n                }).then(\n                    xhr => {\n\n                        this.complete(xhr);\n\n                        if (chunks.length) {\n                            upload(chunks.shift());\n                        } else {\n                            this.completeAll(xhr);\n                        }\n\n                    },\n                    e => this.error(e.message)\n                );\n\n            };\n\n            upload(chunks.shift());\n\n        }\n\n    }\n\n});\n\nfunction match(pattern, path) {\n    return path.match(new RegExp(`^${pattern.replace(/\\//g, '\\\\/').replace(/\\*\\*/g, '(\\\\/[^\\\\/]+)*').replace(/\\*/g, '[^\\\\/]+').replace(/((?!\\\\))\\?/g, '$1.')}$`, 'i'));\n}\n\nfunction chunk(files, size) {\n    const chunks = [];\n    for (let i = 0; i < files.length; i += size) {\n        const chunk = [];\n        for (let j = 0; j < size; j++) {\n            chunk.push(files[i + j]);\n        }\n        chunks.push(chunk);\n    }\n    return chunks;\n}\n\nfunction stop(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\n\n// CONCATENATED MODULE: ./src/js/uikit.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuikit_core.component('countdown', countdown);\nuikit_core.component('filter', components_filter);\nuikit_core.component('lightbox', lightbox);\nuikit_core.component('lightboxPanel', lightbox_panel);\nuikit_core.component('notification', notification);\nuikit_core.component('parallax', components_parallax);\nuikit_core.component('slider', components_slider);\nuikit_core.component('sliderParallax', slider_parallax);\nuikit_core.component('slideshow', components_slideshow);\nuikit_core.component('slideshowParallax', slider_parallax);\nuikit_core.component('sortable', components_sortable);\nuikit_core.component('tooltip', tooltip);\nuikit_core.component('upload', components_upload);\n\nif (true) {\n    boot(uikit_core);\n}\n\n/* harmony default export */ var uikit = __webpack_exports__[\"default\"] = (uikit_core);\n\n\n//# sourceURL=webpack://UIkit/./src/js/uikit.js_+_86_modules?");

/***/ }),

/***/ "./src/js/util/lang.js":
/*!*****************************!*\
  !*** ./src/js/util/lang.js ***!
  \*****************************/
/*! exports provided: bind, hasOwn, hyphenate, camelize, ucfirst, startsWith, endsWith, includes, isArray, isFunction, isObject, isPlainObject, isWindow, isDocument, isJQuery, isNode, isNodeCollection, isBoolean, isString, isNumber, isNumeric, isUndefined, toBoolean, toNumber, toFloat, toNode, toNodes, toList, toMs, swap, assign, each, sortBy, clamp, noop, intersectRect, pointInRect, Dimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return bind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasOwn\", function() { return hasOwn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hyphenate\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"camelize\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ucfirst\", function() { return ucfirst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"includes\", function() { return includes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObject\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWindow\", function() { return isWindow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDocument\", function() { return isDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isJQuery\", function() { return isJQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNode\", function() { return isNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNodeCollection\", function() { return isNodeCollection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBoolean\", function() { return isBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumeric\", function() { return isNumeric; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUndefined\", function() { return isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toBoolean\", function() { return toBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNumber\", function() { return toNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFloat\", function() { return toFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNode\", function() { return toNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNodes\", function() { return toNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toList\", function() { return toList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toMs\", function() { return toMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swap\", function() { return swap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sortBy\", function() { return sortBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRect\", function() { return intersectRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInRect\", function() { return pointInRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dimensions\", function() { return Dimensions; });\nfunction bind(fn, context) {\n    return function (a) {\n        const l = arguments.length;\n        return l ? l > 1 ? fn.apply(context, arguments) : fn.call(context, a) : fn.call(context);\n    };\n}\n\nconst {hasOwnProperty} = Object.prototype;\n\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n\nconst hyphenateRe = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n    return str\n        .replace(hyphenateRe, '$1-$2')\n        .toLowerCase();\n}\n\nconst camelizeRe = /-(\\w)/g;\n\nfunction camelize(str) {\n    return str.replace(camelizeRe, toUpper);\n}\n\nfunction toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n}\n\nfunction ucfirst(str) {\n    return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';\n}\n\nconst strPrototype = String.prototype;\nconst startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };\n\nfunction startsWith(str, search) {\n    return startsWithFn.call(str, search);\n}\n\nconst endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };\n\nfunction endsWith(str, search) {\n    return endsWithFn.call(str, search);\n}\n\nconst includesFn = function (search) { return ~this.indexOf(search); };\nconst includesStr = strPrototype.includes || includesFn;\nconst includesArray = Array.prototype.includes || includesFn;\n\nfunction includes(obj, search) {\n    return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);\n}\n\nconst {isArray} = Array;\n\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nfunction isWindow(obj) {\n    return isObject(obj) && obj === obj.window;\n}\n\nfunction isDocument(obj) {\n    return isObject(obj) && obj.nodeType === 9;\n}\n\nfunction isJQuery(obj) {\n    return isObject(obj) && !!obj.jquery;\n}\n\nfunction isNode(element) {\n    return element instanceof Node || isObject(element) && element.nodeType === 1;\n}\n\nfunction isNodeCollection(element) {\n    return element instanceof NodeList || element instanceof HTMLCollection;\n}\n\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\nfunction isNumeric(value) {\n    return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n}\n\nfunction isUndefined(value) {\n    return value === void 0;\n}\n\nfunction toBoolean(value) {\n    return isBoolean(value)\n        ? value\n        : value === 'true' || value === '1' || value === ''\n            ? true\n            : value === 'false' || value === '0'\n                ? false\n                : value;\n}\n\nfunction toNumber(value) {\n    const number = Number(value);\n    return !isNaN(number) ? number : false;\n}\n\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\nfunction toNode(element) {\n    return isNode(element) || isWindow(element) || isDocument(element)\n        ? element\n        : isNodeCollection(element) || isJQuery(element)\n            ? element[0]\n            : isArray(element)\n                ? toNode(element[0])\n                : null;\n}\n\nconst arrayProto = Array.prototype;\nfunction toNodes(element) {\n    return isNode(element)\n        ? [element]\n        : isNodeCollection(element)\n            ? arrayProto.slice.call(element)\n            : isArray(element)\n                ? element.map(toNode).filter(Boolean)\n                : isJQuery(element)\n                    ? element.toArray()\n                    : [];\n}\n\nfunction toList(value) {\n    return isArray(value)\n        ? value\n        : isString(value)\n            ? value.split(/,(?![^(]*\\))/).map(value => isNumeric(value)\n                ? toNumber(value)\n                : toBoolean(value.trim()))\n            : [value];\n}\n\nfunction toMs(time) {\n    return !time\n        ? 0\n        : endsWith(time, 'ms')\n            ? toFloat(time)\n            : toFloat(time) * 1000;\n}\n\nfunction swap(value, a, b) {\n    return value.replace(new RegExp(`${a}|${b}`, 'mg'), match => {\n        return match === a ? b : a;\n    });\n}\n\nconst assign = Object.assign || function (target, ...args) {\n    target = Object(target);\n    for (let i = 0; i < args.length; i++) {\n        const source = args[i];\n        if (source !== null) {\n            for (const key in source) {\n                if (hasOwn(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    return target;\n};\n\nfunction each(obj, cb) {\n    for (const key in obj) {\n        if (cb.call(obj[key], obj[key], key) === false) {\n            break;\n        }\n    }\n}\n\nfunction sortBy(collection, prop) {\n    return collection.sort((a, b) =>\n        a[prop] > b[prop]\n            ? 1\n            : b[prop] > a[prop]\n            ? -1\n            : 0\n    );\n}\n\nfunction clamp(number, min = 0, max = 1) {\n    return Math.min(Math.max(number, min), max);\n}\n\nfunction noop() {}\n\nfunction intersectRect(r1, r2) {\n    return r1.left <= r2.right &&\n        r2.left <= r1.right &&\n        r1.top <= r2.bottom &&\n        r2.top <= r1.bottom;\n}\n\nfunction pointInRect(point, rect) {\n    return intersectRect({top: point.y, bottom: point.y, left: point.x, right: point.x}, rect);\n}\n\nconst Dimensions = {\n\n    ratio(dimensions, prop, value) {\n\n        const aProp = prop === 'width' ? 'height' : 'width';\n\n        return {\n            [aProp]: Math.round(value * dimensions[aProp] / dimensions[prop]),\n            [prop]: value\n        };\n    },\n\n    contain(dimensions, maxDimensions) {\n        dimensions = assign({}, dimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] > maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    },\n\n    cover(dimensions, maxDimensions) {\n        dimensions = this.contain(dimensions, maxDimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] < maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    }\n\n};\n\n\n//# sourceURL=webpack://UIkit/./src/js/util/lang.js?");

/***/ }),

/***/ "./src/js/util/promise.js":
/*!********************************!*\
  !*** ./src/js/util/promise.js ***!
  \********************************/
/*! exports provided: Promise, Deferred */
/*! ModuleConcatenation bailout: Module uses injected variables (setImmediate) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Promise\", function() { return Promise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Deferred\", function() { return Deferred; });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./src/js/util/lang.js\");\n/* global setImmediate */\n\n\nconst Promise = 'Promise' in window ? window.Promise : PromiseFn;\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nconst RESOLVED = 0;\nconst REJECTED = 1;\nconst PENDING = 2;\n\nconst async = 'setImmediate' in window ? setImmediate : setTimeout;\n\nfunction PromiseFn(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    const promise = this;\n\n    try {\n        executor(\n            x => {\n                promise.resolve(x);\n            },\n            r => {\n                promise.reject(r);\n            }\n        );\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromiseFn.reject = function (r) {\n    return new PromiseFn((resolve, reject) => {\n        reject(r);\n    });\n};\n\nPromiseFn.resolve = function (x) {\n    return new PromiseFn((resolve, reject) => {\n        resolve(x);\n    });\n};\n\nPromiseFn.all = function all(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        const result = [];\n        let count = 0;\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromiseFn.race = function race(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nconst p = PromiseFn.prototype;\n\np.resolve = function resolve(x) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        let called = false;\n\n        try {\n            const then = x && x.then;\n\n            if (x !== null && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isObject\"])(x) && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(then)) {\n                then.call(\n                    x,\n                    x => {\n                        if (!called) {\n                            promise.resolve(x);\n                        }\n                        called = true;\n                    },\n                    r => {\n                        if (!called) {\n                            promise.reject(r);\n                        }\n                        called = true;\n                    }\n                );\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np.reject = function reject(reason) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np.notify = function notify() {\n    async(() => {\n        if (this.state !== PENDING) {\n            while (this.deferred.length) {\n                const [onResolved, onRejected, resolve, reject] = this.deferred.shift();\n\n                try {\n                    if (this.state === RESOLVED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onResolved)) {\n                            resolve(onResolved.call(undefined, this.value));\n                        } else {\n                            resolve(this.value);\n                        }\n                    } else if (this.state === REJECTED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onRejected)) {\n                            resolve(onRejected.call(undefined, this.value));\n                        } else {\n                            reject(this.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np.then = function then(onResolved, onRejected) {\n    return new PromiseFn((resolve, reject) => {\n        this.deferred.push([onResolved, onRejected, resolve, reject]);\n        this.notify();\n    });\n};\n\np.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack://UIkit/./src/js/util/promise.js?");

/***/ })

/******/ })["default"];
});